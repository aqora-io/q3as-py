{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>Q3AS stands for Quantum Algorithms as a Service, a hosted platform for you to run and iterate on quantum and hybrid quantum solutions.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install the SDK from PyPI using <code>pip</code></p> <pre><code>pip install q3as\n</code></pre>"},{"location":"#getting-an-api-key","title":"Getting an API Key","text":"<p>To run your algorithms in the cloud, you have to create an API key and load it into your <code>Credentials</code></p> <p>Start by visiting https://q3as.aqora.io and signing in with your GitHub or Google account. Click on your profile in the top right and go to API Keys. Tap Add API Key and enter a description for your API key. Tap Copy JSON to clipboard and paste the result in a file on your computer.</p>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>Once you've created an API Key and installed the SDK you're ready to create your first quantum job! We're going to first create our client so we can jobs to Q3AS. To do that just load the credentials you've saved in the previous step.</p> <pre><code>from q3as import Client, Credentials\n\ncredentials = Credentials.load(\"path/to/credentials.json\")# (1)!\nclient = Client(credentials)\n</code></pre> <ol> <li>This path should match the path where you saved your API key JSON file.</li> </ol> <p>From here we can start building out the definition of the problem that we would like to solve. We'll start with an NP Hard problem called Maximum Weighted Cut. We can define a graph we would like to cut by supplying a list of edges and their weights.</p> <pre><code>graph = [\n    (0, 1, 1.0),\n    (0, 2, 1.0),\n    (0, 4, 1.0),\n    (1, 2, 1.0),\n    (2, 3, 1.0),\n    (3, 4, 1.0),\n]\n</code></pre> <p>We can then give this graph to our \"Application\" which will define what we want to do with it and how to translate it into the quantum world and back. Q3AS defines multiple such problem domains that you can use.</p> <pre><code>from q3as.app import Maxcut\n\napp = Maxcut(graph)\n</code></pre> <p>We now need to define a solver for our problem. We will use a Variational Quantum Eigensolver or VQE for short</p> <pre><code>from q3as import VQE\n\nvqe = VQE.builder().app(app)\n</code></pre> <p>Now we can send the job to the Q3AS, and let the server handle the computation and the visualization of the intermediate results</p> <pre><code>job = vqe.send(client)\n# get the name of the job\nprint(job.name)\n# wait for and retrieve the results of the job\nprint(job.result())\n</code></pre> <p>Putting it all together we have!</p> <pre><code>from q3as import Client, Credentials, VQE\nfrom q3as.app import Maxcut\n\nclient = Client(Credentials.load(\"credentials.json\"))\n\njob = (\n    VQE\n        .builder()\n        .app(\n            Maxcut([\n                (0, 1, 1.0),\n                (0, 2, 1.0),\n                (0, 4, 1.0),\n                (1, 2, 1.0),\n                (2, 3, 1.0),\n                (3, 4, 1.0),\n            ])\n        )\n        .send(client)\n)\nprint(job.name)\nprint(job.result())\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>q3as<ul> <li>VQE</li> <li>Client</li> <li>Credentials</li> <li>RunOptions</li> <li>EstimatorOptions</li> <li>SamplerOptions</li> <li>Job</li> <li>BaseJob</li> <li>JobRequest</li> <li>JobStatus</li> </ul> </li> <li>q3as.algo<ul> <li>VQE</li> <li>VQEBuilder</li> <li>VQEIteration</li> <li>VQEResult</li> <li>QAOA</li> <li>TwoLocal</li> <li>EfficientSU2</li> <li>Optimizer</li> <li>COBYLA</li> <li>SLSQP</li> <li>HaltReason</li> </ul> </li> <li>q3as.app<ul> <li>Application</li> <li>Qubo</li> <li>Maxcut</li> <li>MaxcutOutput</li> </ul> </li> <li>q3as.quadratic<ul> <li>QuadraticProgram</li> <li>QuadraticProgramToQubo</li> <li>QuadraticProgramElement</li> <li>VarType</li> <li>Variable</li> <li>LinearExpression</li> <li>QuadraticExpression</li> <li>Constraint</li> <li>LinearConstraint</li> <li>QuadraticConstraint</li> <li>QuadraticObjective</li> <li>QuadraticProgramStatus</li> <li>from_ising</li> <li>to_ising</li> </ul> </li> </ul>"},{"location":"reference/q3as/BaseJob/","title":"BaseJob","text":"<p>Base class for a job.</p> Source code in <code>q3as/api.py</code> <pre><code>class BaseJob:\n    \"\"\"\n    Base class for a job.\n    \"\"\"\n\n    info: JobInfo\n    request: JobRequest\n\n    def __init__(self, info: JobInfo, request: JobRequest):\n        self.info = info\n        self.request = request\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        The name of the job.\n        \"\"\"\n        return self.info.slug\n\n    @property\n    def status(self) -&gt; JobStatus:\n        \"\"\"\n        The status of the job.\n        \"\"\"\n        return self.info.status\n\n    @property\n    def input(self) -&gt; VQE:\n        \"\"\"\n        The input VQE.\n        \"\"\"\n        return self.request.input.decode()\n\n    @property\n    def run_options(self) -&gt; RunOptions:\n        \"\"\"\n        The run options.\n        \"\"\"\n        return self.request.run_options\n\n    @property\n    def created_at(self) -&gt; datetime.datetime:\n        \"\"\"\n        The time the job was created.\n        \"\"\"\n        return self.info.created_at\n\n    @property\n    def updated_at(self) -&gt; Optional[datetime.datetime]:\n        \"\"\"\n        The time the job was last updated.\n        \"\"\"\n        return self.info.updated_at\n\n    @property\n    def finished_at(self) -&gt; Optional[datetime.datetime]:\n        \"\"\"\n        The time the job finished.\n        \"\"\"\n        return self.info.finished_at\n</code></pre>"},{"location":"reference/q3as/BaseJob/#q3as.BaseJob.created_at","title":"<code>created_at: datetime.datetime</code>  <code>property</code>","text":"<p>The time the job was created.</p>"},{"location":"reference/q3as/BaseJob/#q3as.BaseJob.finished_at","title":"<code>finished_at: Optional[datetime.datetime]</code>  <code>property</code>","text":"<p>The time the job finished.</p>"},{"location":"reference/q3as/BaseJob/#q3as.BaseJob.input","title":"<code>input: VQE</code>  <code>property</code>","text":"<p>The input VQE.</p>"},{"location":"reference/q3as/BaseJob/#q3as.BaseJob.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>The name of the job.</p>"},{"location":"reference/q3as/BaseJob/#q3as.BaseJob.run_options","title":"<code>run_options: RunOptions</code>  <code>property</code>","text":"<p>The run options.</p>"},{"location":"reference/q3as/BaseJob/#q3as.BaseJob.status","title":"<code>status: JobStatus</code>  <code>property</code>","text":"<p>The status of the job.</p>"},{"location":"reference/q3as/BaseJob/#q3as.BaseJob.updated_at","title":"<code>updated_at: Optional[datetime.datetime]</code>  <code>property</code>","text":"<p>The time the job was last updated.</p>"},{"location":"reference/q3as/Client/","title":"Client","text":"<p>               Bases: <code>AbstractContextManager</code></p> <p>Synchronous client for creating and managing Jobs</p> Source code in <code>q3as/client.py</code> <pre><code>class Client(AbstractContextManager):\n    \"\"\"Synchronous client for creating and managing Jobs\"\"\"\n\n    client: BaseClient\n    req: RequestBuilder\n    res: ResponseBuilder\n\n    def __init__(self, credentials: Credentials, *, url: str = \"https://q3as.aqora.io\"):\n        \"\"\"Create a new client instance\"\"\"\n        self.req = RequestBuilder(url)\n        self.res = ResponseBuilder()\n        self.client = BaseClient(auth=credentials.auth())\n\n    def close(self):\n        \"\"\"\n        Close the client\n        \"\"\"\n        self.client.close()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *_):\n        self.close()\n\n    def _send[T: BaseModel](self, request: Tuple[Type[T], Request]) -&gt; T:\n        return self.res.parse(request[0], self.client.send(request[1]))\n\n    def _create_job(self, job: JobRequest) -&gt; JobInfo:\n        return self._send(self.req.create_job(job))\n\n    def _get_job_info(self, slug: str) -&gt; JobInfo:\n        return self._send(self.req.get_job_info(slug))\n\n    def _get_job_request(self, slug: str) -&gt; JobRequest:\n        return self._send(self.req.get_job_request(slug))\n\n    def _get_job_result(self, slug: str) -&gt; JobResult:\n        return self._send(self.req.get_job_result(slug))\n\n    def _pause_job(self, slug: str) -&gt; JobInfo:\n        return self._send(self.req.pause_job(slug))\n\n    def _resume_job(self, slug: str) -&gt; JobInfo:\n        return self._send(self.req.resume_job(slug))\n\n    def _delete_job(self, slug: str) -&gt; JobInfo:\n        return self._send(self.req.delete_job(slug))\n\n    def _wait_for_job(\n        self,\n        name: str,\n        polling_interval: float = 1.0,\n        max_wait: Optional[float] = None,\n    ) -&gt; Tuple[JobInfo, JobResult]:\n        started = time.time()\n        while True:\n            job = self._get_job_info(name)\n            if job.status is not JobStatus.STARTED:\n                result = self._get_job_result(name)\n                if result.is_some():\n                    return (job, result)\n            if max_wait is not None and time.time() - started &gt;= max_wait:\n                raise TimeoutError(\"Job did not finish in time\")\n            time.sleep(polling_interval)\n\n    def create_job(self, request: JobRequest) -&gt; Job:\n        \"\"\"\n        Create a new Job\n        \"\"\"\n        info = self._create_job(request)\n        modified_request = self._get_job_request(info.slug)\n        return Job(self, info, modified_request)\n\n    def get_job(self, name: str) -&gt; Job:\n        \"\"\"\n        Get a job by name\n        \"\"\"\n        info = self._get_job_info(name)\n        request = self._get_job_request(name)\n        return Job(self, info, request)\n</code></pre>"},{"location":"reference/q3as/Client/#q3as.Client.__init__","title":"<code>__init__(credentials, *, url='https://q3as.aqora.io')</code>","text":"<p>Create a new client instance</p> Source code in <code>q3as/client.py</code> <pre><code>def __init__(self, credentials: Credentials, *, url: str = \"https://q3as.aqora.io\"):\n    \"\"\"Create a new client instance\"\"\"\n    self.req = RequestBuilder(url)\n    self.res = ResponseBuilder()\n    self.client = BaseClient(auth=credentials.auth())\n</code></pre>"},{"location":"reference/q3as/Client/#q3as.Client.close","title":"<code>close()</code>","text":"<p>Close the client</p> Source code in <code>q3as/client.py</code> <pre><code>def close(self):\n    \"\"\"\n    Close the client\n    \"\"\"\n    self.client.close()\n</code></pre>"},{"location":"reference/q3as/Client/#q3as.Client.create_job","title":"<code>create_job(request)</code>","text":"<p>Create a new Job</p> Source code in <code>q3as/client.py</code> <pre><code>def create_job(self, request: JobRequest) -&gt; Job:\n    \"\"\"\n    Create a new Job\n    \"\"\"\n    info = self._create_job(request)\n    modified_request = self._get_job_request(info.slug)\n    return Job(self, info, modified_request)\n</code></pre>"},{"location":"reference/q3as/Client/#q3as.Client.get_job","title":"<code>get_job(name)</code>","text":"<p>Get a job by name</p> Source code in <code>q3as/client.py</code> <pre><code>def get_job(self, name: str) -&gt; Job:\n    \"\"\"\n    Get a job by name\n    \"\"\"\n    info = self._get_job_info(name)\n    request = self._get_job_request(name)\n    return Job(self, info, request)\n</code></pre>"},{"location":"reference/q3as/Credentials/","title":"Credentials","text":"<p>Credentials for authenticating with the server.</p> Source code in <code>q3as/client.py</code> <pre><code>class Credentials:\n    \"\"\"\n    Credentials for authenticating with the server.\n    \"\"\"\n\n    id: str\n    secret: str\n\n    def __init__(self, id: str, secret: str):\n        \"\"\"\n        Create a new credentials instance.\n        \"\"\"\n        self.id = id\n        self.secret = secret\n\n    @classmethod\n    def load(cls, file: str | IOBase):\n        \"\"\"\n        Load credentials from a file.\n        \"\"\"\n        if isinstance(file, str):\n            file = open(file)\n        return cls(**json.load(file))\n\n    def auth(self):\n        return BasicAuth(self.id, self.secret)\n</code></pre>"},{"location":"reference/q3as/Credentials/#q3as.Credentials.__init__","title":"<code>__init__(id, secret)</code>","text":"<p>Create a new credentials instance.</p> Source code in <code>q3as/client.py</code> <pre><code>def __init__(self, id: str, secret: str):\n    \"\"\"\n    Create a new credentials instance.\n    \"\"\"\n    self.id = id\n    self.secret = secret\n</code></pre>"},{"location":"reference/q3as/Credentials/#q3as.Credentials.load","title":"<code>load(file)</code>  <code>classmethod</code>","text":"<p>Load credentials from a file.</p> Source code in <code>q3as/client.py</code> <pre><code>@classmethod\ndef load(cls, file: str | IOBase):\n    \"\"\"\n    Load credentials from a file.\n    \"\"\"\n    if isinstance(file, str):\n        file = open(file)\n    return cls(**json.load(file))\n</code></pre>"},{"location":"reference/q3as/EstimatorOptions/","title":"EstimatorOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>Options for the estimator.</p> Source code in <code>q3as/run_options.py</code> <pre><code>class EstimatorOptions(BaseModel):\n    \"\"\"\n    Options for the estimator.\n    \"\"\"\n\n    shots: int = 1024\n    \"Number of shots for the estimator.\"\n</code></pre>"},{"location":"reference/q3as/EstimatorOptions/#q3as.EstimatorOptions.shots","title":"<code>shots: int = 1024</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of shots for the estimator.</p>"},{"location":"reference/q3as/Job/","title":"Job","text":"<p>               Bases: <code>BaseJob</code></p> Source code in <code>q3as/api.py</code> <pre><code>class Job(BaseJob):\n    client: Client\n\n    def __init__(self, client: Client, info: JobInfo, request: JobRequest):\n        super().__init__(info, request)\n        self.client = client\n\n    def result(\n        self, polling_interval: float = 1.0, max_wait: Optional[float] = None\n    ) -&gt; VQEResult:\n        \"\"\"\n        Wait for the job to finish and return result\n        If the job is not finished, return None. If the Job finished with an error, raise an exception.\n        \"\"\"\n        if self.status is not JobStatus.STARTED:\n            vqe_result = self.result_now()\n            if vqe_result is not None:\n                return vqe_result\n        info, result = self.client._wait_for_job(\n            self.info.slug, polling_interval, max_wait\n        )\n        self.info = info\n        vqe_result = result.as_vqe_result()\n        if vqe_result is None:\n            raise ValueError(\"Expected result to not be None\")\n        return vqe_result\n\n    def result_now(self) -&gt; Optional[VQEResult]:\n        \"\"\"\n        Get the result of the job now without waiting for it to finish.\n        If the job is not finished, return None. If the Job finished with an error, raise an exception.\n        \"\"\"\n        self.client._get_job_result(self.info.slug).as_vqe_result()\n\n    def refetch(self) -&gt; Job:\n        \"\"\"\n        Refetch the job from the server.\n        \"\"\"\n        info = self.client._get_job_info(self.info.slug)\n        self.info = info\n        return self\n\n    def pause(self) -&gt; Job:\n        \"\"\"\n        Pause the job.\n        \"\"\"\n        info = self.client._pause_job(self.info.slug)\n        self.info = info\n        return self\n\n    def resume(self) -&gt; Job:\n        \"\"\"\n        Resume the job.\n        \"\"\"\n        info = self.client._resume_job(self.info.slug)\n        self.info = info\n        return self\n\n    def delete(self) -&gt; Job:\n        \"\"\"\n        Delete the job.\n        \"\"\"\n        info = self.client._delete_job(self.info.slug)\n        self.info = info\n        return self\n</code></pre>"},{"location":"reference/q3as/Job/#q3as.Job.delete","title":"<code>delete()</code>","text":"<p>Delete the job.</p> Source code in <code>q3as/api.py</code> <pre><code>def delete(self) -&gt; Job:\n    \"\"\"\n    Delete the job.\n    \"\"\"\n    info = self.client._delete_job(self.info.slug)\n    self.info = info\n    return self\n</code></pre>"},{"location":"reference/q3as/Job/#q3as.Job.pause","title":"<code>pause()</code>","text":"<p>Pause the job.</p> Source code in <code>q3as/api.py</code> <pre><code>def pause(self) -&gt; Job:\n    \"\"\"\n    Pause the job.\n    \"\"\"\n    info = self.client._pause_job(self.info.slug)\n    self.info = info\n    return self\n</code></pre>"},{"location":"reference/q3as/Job/#q3as.Job.refetch","title":"<code>refetch()</code>","text":"<p>Refetch the job from the server.</p> Source code in <code>q3as/api.py</code> <pre><code>def refetch(self) -&gt; Job:\n    \"\"\"\n    Refetch the job from the server.\n    \"\"\"\n    info = self.client._get_job_info(self.info.slug)\n    self.info = info\n    return self\n</code></pre>"},{"location":"reference/q3as/Job/#q3as.Job.result","title":"<code>result(polling_interval=1.0, max_wait=None)</code>","text":"<p>Wait for the job to finish and return result If the job is not finished, return None. If the Job finished with an error, raise an exception.</p> Source code in <code>q3as/api.py</code> <pre><code>def result(\n    self, polling_interval: float = 1.0, max_wait: Optional[float] = None\n) -&gt; VQEResult:\n    \"\"\"\n    Wait for the job to finish and return result\n    If the job is not finished, return None. If the Job finished with an error, raise an exception.\n    \"\"\"\n    if self.status is not JobStatus.STARTED:\n        vqe_result = self.result_now()\n        if vqe_result is not None:\n            return vqe_result\n    info, result = self.client._wait_for_job(\n        self.info.slug, polling_interval, max_wait\n    )\n    self.info = info\n    vqe_result = result.as_vqe_result()\n    if vqe_result is None:\n        raise ValueError(\"Expected result to not be None\")\n    return vqe_result\n</code></pre>"},{"location":"reference/q3as/Job/#q3as.Job.result_now","title":"<code>result_now()</code>","text":"<p>Get the result of the job now without waiting for it to finish. If the job is not finished, return None. If the Job finished with an error, raise an exception.</p> Source code in <code>q3as/api.py</code> <pre><code>def result_now(self) -&gt; Optional[VQEResult]:\n    \"\"\"\n    Get the result of the job now without waiting for it to finish.\n    If the job is not finished, return None. If the Job finished with an error, raise an exception.\n    \"\"\"\n    self.client._get_job_result(self.info.slug).as_vqe_result()\n</code></pre>"},{"location":"reference/q3as/Job/#q3as.Job.resume","title":"<code>resume()</code>","text":"<p>Resume the job.</p> Source code in <code>q3as/api.py</code> <pre><code>def resume(self) -&gt; Job:\n    \"\"\"\n    Resume the job.\n    \"\"\"\n    info = self.client._resume_job(self.info.slug)\n    self.info = info\n    return self\n</code></pre>"},{"location":"reference/q3as/JobRequest/","title":"JobRequest","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request to run a VQE job.</p> Source code in <code>q3as/api.py</code> <pre><code>class JobRequest(BaseModel):\n    \"\"\"\n    Request to run a VQE job.\n    \"\"\"\n\n    input: EncodedVQE\n    \"The input VQE to run.\"\n    run_options: RunOptions = RunOptions()\n    \"The options to run the VQE with.\"\n\n    def send(self, client: Client) -&gt; Job:\n        \"\"\"\n        Send the request to the server and create a job.\n        \"\"\"\n        return client.create_job(self)\n</code></pre>"},{"location":"reference/q3as/JobRequest/#q3as.JobRequest.input","title":"<code>input: EncodedVQE</code>  <code>instance-attribute</code>","text":"<p>The input VQE to run.</p>"},{"location":"reference/q3as/JobRequest/#q3as.JobRequest.run_options","title":"<code>run_options: RunOptions = RunOptions()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The options to run the VQE with.</p>"},{"location":"reference/q3as/JobRequest/#q3as.JobRequest.send","title":"<code>send(client)</code>","text":"<p>Send the request to the server and create a job.</p> Source code in <code>q3as/api.py</code> <pre><code>def send(self, client: Client) -&gt; Job:\n    \"\"\"\n    Send the request to the server and create a job.\n    \"\"\"\n    return client.create_job(self)\n</code></pre>"},{"location":"reference/q3as/JobStatus/","title":"JobStatus","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing the status of a job.</p> Source code in <code>q3as/api.py</code> <pre><code>class JobStatus(Enum):\n    \"\"\"\n    Enum representing the status of a job.\n    \"\"\"\n\n    STARTED = 0\n    \"The job is started.\"\n    PAUSED = 1\n    \"The job is paused.\"\n    SUCCESS = 2\n    \"The job finished successfully.\"\n    ERROR = 3\n    \"The job finished with an error.\"\n</code></pre>"},{"location":"reference/q3as/JobStatus/#q3as.JobStatus.ERROR","title":"<code>ERROR = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The job finished with an error.</p>"},{"location":"reference/q3as/JobStatus/#q3as.JobStatus.PAUSED","title":"<code>PAUSED = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The job is paused.</p>"},{"location":"reference/q3as/JobStatus/#q3as.JobStatus.STARTED","title":"<code>STARTED = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The job is started.</p>"},{"location":"reference/q3as/JobStatus/#q3as.JobStatus.SUCCESS","title":"<code>SUCCESS = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The job finished successfully.</p>"},{"location":"reference/q3as/RunOptions/","title":"RunOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>Options for  running in the cloud.</p> Source code in <code>q3as/run_options.py</code> <pre><code>class RunOptions(BaseModel):\n    \"\"\"\n    Options for  running in the cloud.\n    \"\"\"\n\n    backend: BackendName = \"auto\"\n    \"Name of the backend to use. See `q3as.run_options.BackendName` for possible values.\"\n    sampler: SamplerOptions = SamplerOptions()\n    \"Options for the sampler.\"\n    estimator: EstimatorOptions = EstimatorOptions()\n    \"Options for the estimator.\"\n</code></pre>"},{"location":"reference/q3as/RunOptions/#q3as.RunOptions.backend","title":"<code>backend: BackendName = 'auto'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of the backend to use. See <code>q3as.run_options.BackendName</code> for possible values.</p>"},{"location":"reference/q3as/RunOptions/#q3as.RunOptions.estimator","title":"<code>estimator: EstimatorOptions = EstimatorOptions()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Options for the estimator.</p>"},{"location":"reference/q3as/RunOptions/#q3as.RunOptions.sampler","title":"<code>sampler: SamplerOptions = SamplerOptions()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Options for the sampler.</p>"},{"location":"reference/q3as/SamplerOptions/","title":"SamplerOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>Options for the sampler.</p> Source code in <code>q3as/run_options.py</code> <pre><code>class SamplerOptions(BaseModel):\n    \"\"\"\n    Options for the sampler.\n    \"\"\"\n\n    shots: int = 1024\n    \"Number of shots for the sampler.\"\n</code></pre>"},{"location":"reference/q3as/SamplerOptions/#q3as.SamplerOptions.shots","title":"<code>shots: int = 1024</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of shots for the sampler.</p>"},{"location":"reference/q3as/VQE/","title":"VQE","text":"<p>Parameters for running VQE</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>@dataclass\nclass VQE:\n    \"\"\"\n    Parameters for running VQE\n    \"\"\"\n\n    ansatz: QuantumCircuit\n    \"The ansatz circuit\"\n    observables: ObservablesArray\n    \"The observables to estimate. E.g. the Hamiltonian of the system\"\n    initial_params: np.ndarray\n    \"The initial parameters of the ansatz\"\n    optimizer: Optimizer\n    \"The optimizer to use\"\n    app: Optional[Application]\n    \"The application to use for interpretation of results\"\n    maxiter: int = 1000\n    \"The maximum number of iterations\"\n\n    @classmethod\n    def builder(cls) -&gt; VQEBuilder:\n        \"\"\"\n        Create a builder for VQE\n        \"\"\"\n        return VQEBuilder()\n\n    def run(\n        self,\n        estimator: Estimator,\n        sampler: Optional[Sampler] = None,\n        callback: Optional[Callable[[VQEIteration], None]] = None,\n    ) -&gt; VQEResult:\n        \"\"\"\n        Run VQE\n        \"\"\"\n\n        out = VQEResult(params=self.initial_params)\n\n        def cost_fun(\n            params: np.ndarray,\n        ):\n            out.iter += 1\n            bound_params = BindingsArray.coerce({tuple(self.ansatz.parameters): params})\n            pub = EstimatorPub(self.ansatz, self.observables, bound_params)\n            result = estimator.run([pub]).result()\n            cost = cast(EstimatorData, result[0].data).evs\n            vqe_result = VQEIteration(\n                iter=out.iter, cost=cost, params=params, estimated=result\n            )\n            if out.cost is None or cost &lt; out.cost:\n                vqe_result.best = True\n                out.params = params\n                out.cost = cost\n                out.estimated = vqe_result.estimated\n            if callback is not None:\n                callback(vqe_result)\n            return cost\n\n        try:\n            res = minimize(\n                cost_fun,\n                self.initial_params,\n                method=self.optimizer.scipy_method,\n                options={\"maxiter\": self.maxiter},\n            )\n            if res.success:\n                out.reason = HaltReason.TOLERANCE\n            else:\n                out.reason = HaltReason.MAXITER\n        except StopIteration:\n            out.reason = HaltReason.INTERRUPT\n\n        if sampler is not None:\n            bound_params = cast(\n                BindingsArrayLike,\n                BindingsArray.coerce({tuple(self.ansatz.parameters): out.params}).data,\n            )\n            measured_ansatz = cast(\n                QuantumCircuit, self.ansatz.measure_all(inplace=False)\n            )\n            sampled = sampler.run([(measured_ansatz, bound_params)]).result()\n\n            out.sampled = sampled\n\n            meas = cast(SamplerData, sampled[0].data).meas\n            out.meas_counts = meas.get_counts()\n\n            if self.app is not None:\n                out.interpreted = self.app.interpreted_meas(meas)\n\n        return out\n\n    def send(self, api: Client, run_options: RunOptions = RunOptions()) -&gt; Job:\n        \"\"\"\n        Send the VQE job to the API\n        \"\"\"\n        return api.create_job(\n            q3as.api.JobRequest(\n                input=q3as.encoding.EncodedVQE.encode(self), run_options=run_options\n            )\n        )\n</code></pre>"},{"location":"reference/q3as/VQE/#q3as.VQE.ansatz","title":"<code>ansatz: QuantumCircuit</code>  <code>instance-attribute</code>","text":"<p>The ansatz circuit</p>"},{"location":"reference/q3as/VQE/#q3as.VQE.app","title":"<code>app: Optional[Application]</code>  <code>instance-attribute</code>","text":"<p>The application to use for interpretation of results</p>"},{"location":"reference/q3as/VQE/#q3as.VQE.initial_params","title":"<code>initial_params: np.ndarray</code>  <code>instance-attribute</code>","text":"<p>The initial parameters of the ansatz</p>"},{"location":"reference/q3as/VQE/#q3as.VQE.maxiter","title":"<code>maxiter: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The maximum number of iterations</p>"},{"location":"reference/q3as/VQE/#q3as.VQE.observables","title":"<code>observables: ObservablesArray</code>  <code>instance-attribute</code>","text":"<p>The observables to estimate. E.g. the Hamiltonian of the system</p>"},{"location":"reference/q3as/VQE/#q3as.VQE.optimizer","title":"<code>optimizer: Optimizer</code>  <code>instance-attribute</code>","text":"<p>The optimizer to use</p>"},{"location":"reference/q3as/VQE/#q3as.VQE.builder","title":"<code>builder()</code>  <code>classmethod</code>","text":"<p>Create a builder for VQE</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>@classmethod\ndef builder(cls) -&gt; VQEBuilder:\n    \"\"\"\n    Create a builder for VQE\n    \"\"\"\n    return VQEBuilder()\n</code></pre>"},{"location":"reference/q3as/VQE/#q3as.VQE.run","title":"<code>run(estimator, sampler=None, callback=None)</code>","text":"<p>Run VQE</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>def run(\n    self,\n    estimator: Estimator,\n    sampler: Optional[Sampler] = None,\n    callback: Optional[Callable[[VQEIteration], None]] = None,\n) -&gt; VQEResult:\n    \"\"\"\n    Run VQE\n    \"\"\"\n\n    out = VQEResult(params=self.initial_params)\n\n    def cost_fun(\n        params: np.ndarray,\n    ):\n        out.iter += 1\n        bound_params = BindingsArray.coerce({tuple(self.ansatz.parameters): params})\n        pub = EstimatorPub(self.ansatz, self.observables, bound_params)\n        result = estimator.run([pub]).result()\n        cost = cast(EstimatorData, result[0].data).evs\n        vqe_result = VQEIteration(\n            iter=out.iter, cost=cost, params=params, estimated=result\n        )\n        if out.cost is None or cost &lt; out.cost:\n            vqe_result.best = True\n            out.params = params\n            out.cost = cost\n            out.estimated = vqe_result.estimated\n        if callback is not None:\n            callback(vqe_result)\n        return cost\n\n    try:\n        res = minimize(\n            cost_fun,\n            self.initial_params,\n            method=self.optimizer.scipy_method,\n            options={\"maxiter\": self.maxiter},\n        )\n        if res.success:\n            out.reason = HaltReason.TOLERANCE\n        else:\n            out.reason = HaltReason.MAXITER\n    except StopIteration:\n        out.reason = HaltReason.INTERRUPT\n\n    if sampler is not None:\n        bound_params = cast(\n            BindingsArrayLike,\n            BindingsArray.coerce({tuple(self.ansatz.parameters): out.params}).data,\n        )\n        measured_ansatz = cast(\n            QuantumCircuit, self.ansatz.measure_all(inplace=False)\n        )\n        sampled = sampler.run([(measured_ansatz, bound_params)]).result()\n\n        out.sampled = sampled\n\n        meas = cast(SamplerData, sampled[0].data).meas\n        out.meas_counts = meas.get_counts()\n\n        if self.app is not None:\n            out.interpreted = self.app.interpreted_meas(meas)\n\n    return out\n</code></pre>"},{"location":"reference/q3as/VQE/#q3as.VQE.send","title":"<code>send(api, run_options=RunOptions())</code>","text":"<p>Send the VQE job to the API</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>def send(self, api: Client, run_options: RunOptions = RunOptions()) -&gt; Job:\n    \"\"\"\n    Send the VQE job to the API\n    \"\"\"\n    return api.create_job(\n        q3as.api.JobRequest(\n            input=q3as.encoding.EncodedVQE.encode(self), run_options=run_options\n        )\n    )\n</code></pre>"},{"location":"reference/q3as.algo/COBYLA/","title":"COBYLA","text":"<p>               Bases: <code>Optimizer</code></p> Source code in <code>q3as/algo/optimizer.py</code> <pre><code>class COBYLA(Optimizer):\n    @property\n    def scipy_method(self) -&gt; str:\n        return \"COBYLA\"\n</code></pre>"},{"location":"reference/q3as.algo/EfficientSU2/","title":"EfficientSU2","text":"<p>A builder for the EfficientSU2 ansatz</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>class EfficientSU2:\n    \"\"\"\n    A builder for the EfficientSU2 ansatz\n    \"\"\"\n\n    def __init__(self, postprocess: _PostProcessCallable = None, **kwargs):\n        \"\"\"\n        Create a new EfficientSU2 builder. Arguments are passed to the EfficientSU2 constructor in the Qiskit circuit library.\n        \"\"\"\n        self.postprocess = postprocess\n        self.kwargs = kwargs\n\n    def __call__(self, obs: ObservablesArray) -&gt; QuantumCircuit:\n        ansatz = EfficientSU2Ansatz(\n            _observables_to_pauli(obs).num_qubits, **self.kwargs\n        )\n        if self.postprocess is not None:\n            ansatz = self.postprocess(ansatz)\n        return ansatz\n</code></pre>"},{"location":"reference/q3as.algo/EfficientSU2/#q3as.algo.EfficientSU2.__init__","title":"<code>__init__(postprocess=None, **kwargs)</code>","text":"<p>Create a new EfficientSU2 builder. Arguments are passed to the EfficientSU2 constructor in the Qiskit circuit library.</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>def __init__(self, postprocess: _PostProcessCallable = None, **kwargs):\n    \"\"\"\n    Create a new EfficientSU2 builder. Arguments are passed to the EfficientSU2 constructor in the Qiskit circuit library.\n    \"\"\"\n    self.postprocess = postprocess\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/q3as.algo/HaltReason/","title":"HaltReason","text":"<p>               Bases: <code>Enum</code></p> <p>The reason for halting</p> Source code in <code>q3as/algo/types.py</code> <pre><code>class HaltReason(Enum):\n    \"\"\"\n    The reason for halting\n    \"\"\"\n\n    TOLERANCE = \"tolerance\"\n    \"The tolerance was reached\"\n    INTERRUPT = \"interrupt\"\n    \"The process was interrupted\"\n    MAXITER = \"maxiter\"\n    \"The maximum number of iterations was reached\"\n</code></pre>"},{"location":"reference/q3as.algo/HaltReason/#q3as.algo.HaltReason.INTERRUPT","title":"<code>INTERRUPT = 'interrupt'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The process was interrupted</p>"},{"location":"reference/q3as.algo/HaltReason/#q3as.algo.HaltReason.MAXITER","title":"<code>MAXITER = 'maxiter'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The maximum number of iterations was reached</p>"},{"location":"reference/q3as.algo/HaltReason/#q3as.algo.HaltReason.TOLERANCE","title":"<code>TOLERANCE = 'tolerance'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The tolerance was reached</p>"},{"location":"reference/q3as.algo/Optimizer/","title":"Optimizer","text":"<p>               Bases: <code>ABC</code></p> <p>An optimizer for variational algorithms.</p> Source code in <code>q3as/algo/optimizer.py</code> <pre><code>class Optimizer(ABC):\n    \"\"\"An optimizer for variational algorithms.\"\"\"\n\n    @property\n    @abstractmethod\n    def scipy_method(self) -&gt; str:\n        \"\"\"The name of the optimizer method in scipy.optimize.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/q3as.algo/Optimizer/#q3as.algo.Optimizer.scipy_method","title":"<code>scipy_method: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>The name of the optimizer method in scipy.optimize.</p>"},{"location":"reference/q3as.algo/QAOA/","title":"QAOA","text":"<p>A builder for the QAOA ansatz</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>class QAOA:\n    \"\"\"\n    A builder for the QAOA ansatz\n    \"\"\"\n\n    def __init__(self, postprocess: _PostProcessCallable = None, **kwargs):\n        \"\"\"\n        Create a new QAOA builder. Arguments are passed to the QAOAAnsatz constructor in the Qiskit circuit library.\n        \"\"\"\n        self.postprocess = postprocess\n        self.kwargs = kwargs\n\n    def __call__(self, obs: ObservablesArray) -&gt; QuantumCircuit:\n        ansatz = QAOAAnsatz(_observables_to_pauli(obs), **self.kwargs)\n        if self.postprocess is not None:\n            ansatz = self.postprocess(ansatz)\n        return ansatz\n</code></pre>"},{"location":"reference/q3as.algo/QAOA/#q3as.algo.QAOA.__init__","title":"<code>__init__(postprocess=None, **kwargs)</code>","text":"<p>Create a new QAOA builder. Arguments are passed to the QAOAAnsatz constructor in the Qiskit circuit library.</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>def __init__(self, postprocess: _PostProcessCallable = None, **kwargs):\n    \"\"\"\n    Create a new QAOA builder. Arguments are passed to the QAOAAnsatz constructor in the Qiskit circuit library.\n    \"\"\"\n    self.postprocess = postprocess\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/q3as.algo/SLSQP/","title":"SLSQP","text":"<p>               Bases: <code>Optimizer</code></p> Source code in <code>q3as/algo/optimizer.py</code> <pre><code>class SLSQP(Optimizer):\n    @property\n    def scipy_method(self) -&gt; str:\n        return \"SLSQP\"\n</code></pre>"},{"location":"reference/q3as.algo/TwoLocal/","title":"TwoLocal","text":"<p>A builder for the TwoLocal ansatz</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>class TwoLocal:\n    \"\"\"\n    A builder for the TwoLocal ansatz\n    \"\"\"\n\n    def __init__(self, postprocess: _PostProcessCallable = None, **kwargs):\n        \"\"\"\n        Create a new TwoLocal builder. Arguments are passed to the TwoLocal constructor in the Qiskit circuit library.\n        \"\"\"\n        self.postprocess = postprocess\n        self.kwargs = kwargs\n\n    def __call__(self, obs: ObservablesArray) -&gt; QuantumCircuit:\n        ansatz = TwoLocalAnsatz(_observables_to_pauli(obs).num_qubits, **self.kwargs)\n        if self.postprocess is not None:\n            ansatz = self.postprocess(ansatz)\n        return ansatz\n</code></pre>"},{"location":"reference/q3as.algo/TwoLocal/#q3as.algo.TwoLocal.__init__","title":"<code>__init__(postprocess=None, **kwargs)</code>","text":"<p>Create a new TwoLocal builder. Arguments are passed to the TwoLocal constructor in the Qiskit circuit library.</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>def __init__(self, postprocess: _PostProcessCallable = None, **kwargs):\n    \"\"\"\n    Create a new TwoLocal builder. Arguments are passed to the TwoLocal constructor in the Qiskit circuit library.\n    \"\"\"\n    self.postprocess = postprocess\n    self.kwargs = kwargs\n</code></pre>"},{"location":"reference/q3as.algo/VQE/","title":"VQE","text":"<p>Parameters for running VQE</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>@dataclass\nclass VQE:\n    \"\"\"\n    Parameters for running VQE\n    \"\"\"\n\n    ansatz: QuantumCircuit\n    \"The ansatz circuit\"\n    observables: ObservablesArray\n    \"The observables to estimate. E.g. the Hamiltonian of the system\"\n    initial_params: np.ndarray\n    \"The initial parameters of the ansatz\"\n    optimizer: Optimizer\n    \"The optimizer to use\"\n    app: Optional[Application]\n    \"The application to use for interpretation of results\"\n    maxiter: int = 1000\n    \"The maximum number of iterations\"\n\n    @classmethod\n    def builder(cls) -&gt; VQEBuilder:\n        \"\"\"\n        Create a builder for VQE\n        \"\"\"\n        return VQEBuilder()\n\n    def run(\n        self,\n        estimator: Estimator,\n        sampler: Optional[Sampler] = None,\n        callback: Optional[Callable[[VQEIteration], None]] = None,\n    ) -&gt; VQEResult:\n        \"\"\"\n        Run VQE\n        \"\"\"\n\n        out = VQEResult(params=self.initial_params)\n\n        def cost_fun(\n            params: np.ndarray,\n        ):\n            out.iter += 1\n            bound_params = BindingsArray.coerce({tuple(self.ansatz.parameters): params})\n            pub = EstimatorPub(self.ansatz, self.observables, bound_params)\n            result = estimator.run([pub]).result()\n            cost = cast(EstimatorData, result[0].data).evs\n            vqe_result = VQEIteration(\n                iter=out.iter, cost=cost, params=params, estimated=result\n            )\n            if out.cost is None or cost &lt; out.cost:\n                vqe_result.best = True\n                out.params = params\n                out.cost = cost\n                out.estimated = vqe_result.estimated\n            if callback is not None:\n                callback(vqe_result)\n            return cost\n\n        try:\n            res = minimize(\n                cost_fun,\n                self.initial_params,\n                method=self.optimizer.scipy_method,\n                options={\"maxiter\": self.maxiter},\n            )\n            if res.success:\n                out.reason = HaltReason.TOLERANCE\n            else:\n                out.reason = HaltReason.MAXITER\n        except StopIteration:\n            out.reason = HaltReason.INTERRUPT\n\n        if sampler is not None:\n            bound_params = cast(\n                BindingsArrayLike,\n                BindingsArray.coerce({tuple(self.ansatz.parameters): out.params}).data,\n            )\n            measured_ansatz = cast(\n                QuantumCircuit, self.ansatz.measure_all(inplace=False)\n            )\n            sampled = sampler.run([(measured_ansatz, bound_params)]).result()\n\n            out.sampled = sampled\n\n            meas = cast(SamplerData, sampled[0].data).meas\n            out.meas_counts = meas.get_counts()\n\n            if self.app is not None:\n                out.interpreted = self.app.interpreted_meas(meas)\n\n        return out\n\n    def send(self, api: Client, run_options: RunOptions = RunOptions()) -&gt; Job:\n        \"\"\"\n        Send the VQE job to the API\n        \"\"\"\n        return api.create_job(\n            q3as.api.JobRequest(\n                input=q3as.encoding.EncodedVQE.encode(self), run_options=run_options\n            )\n        )\n</code></pre>"},{"location":"reference/q3as.algo/VQE/#q3as.algo.VQE.ansatz","title":"<code>ansatz: QuantumCircuit</code>  <code>instance-attribute</code>","text":"<p>The ansatz circuit</p>"},{"location":"reference/q3as.algo/VQE/#q3as.algo.VQE.app","title":"<code>app: Optional[Application]</code>  <code>instance-attribute</code>","text":"<p>The application to use for interpretation of results</p>"},{"location":"reference/q3as.algo/VQE/#q3as.algo.VQE.initial_params","title":"<code>initial_params: np.ndarray</code>  <code>instance-attribute</code>","text":"<p>The initial parameters of the ansatz</p>"},{"location":"reference/q3as.algo/VQE/#q3as.algo.VQE.maxiter","title":"<code>maxiter: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The maximum number of iterations</p>"},{"location":"reference/q3as.algo/VQE/#q3as.algo.VQE.observables","title":"<code>observables: ObservablesArray</code>  <code>instance-attribute</code>","text":"<p>The observables to estimate. E.g. the Hamiltonian of the system</p>"},{"location":"reference/q3as.algo/VQE/#q3as.algo.VQE.optimizer","title":"<code>optimizer: Optimizer</code>  <code>instance-attribute</code>","text":"<p>The optimizer to use</p>"},{"location":"reference/q3as.algo/VQE/#q3as.algo.VQE.builder","title":"<code>builder()</code>  <code>classmethod</code>","text":"<p>Create a builder for VQE</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>@classmethod\ndef builder(cls) -&gt; VQEBuilder:\n    \"\"\"\n    Create a builder for VQE\n    \"\"\"\n    return VQEBuilder()\n</code></pre>"},{"location":"reference/q3as.algo/VQE/#q3as.algo.VQE.run","title":"<code>run(estimator, sampler=None, callback=None)</code>","text":"<p>Run VQE</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>def run(\n    self,\n    estimator: Estimator,\n    sampler: Optional[Sampler] = None,\n    callback: Optional[Callable[[VQEIteration], None]] = None,\n) -&gt; VQEResult:\n    \"\"\"\n    Run VQE\n    \"\"\"\n\n    out = VQEResult(params=self.initial_params)\n\n    def cost_fun(\n        params: np.ndarray,\n    ):\n        out.iter += 1\n        bound_params = BindingsArray.coerce({tuple(self.ansatz.parameters): params})\n        pub = EstimatorPub(self.ansatz, self.observables, bound_params)\n        result = estimator.run([pub]).result()\n        cost = cast(EstimatorData, result[0].data).evs\n        vqe_result = VQEIteration(\n            iter=out.iter, cost=cost, params=params, estimated=result\n        )\n        if out.cost is None or cost &lt; out.cost:\n            vqe_result.best = True\n            out.params = params\n            out.cost = cost\n            out.estimated = vqe_result.estimated\n        if callback is not None:\n            callback(vqe_result)\n        return cost\n\n    try:\n        res = minimize(\n            cost_fun,\n            self.initial_params,\n            method=self.optimizer.scipy_method,\n            options={\"maxiter\": self.maxiter},\n        )\n        if res.success:\n            out.reason = HaltReason.TOLERANCE\n        else:\n            out.reason = HaltReason.MAXITER\n    except StopIteration:\n        out.reason = HaltReason.INTERRUPT\n\n    if sampler is not None:\n        bound_params = cast(\n            BindingsArrayLike,\n            BindingsArray.coerce({tuple(self.ansatz.parameters): out.params}).data,\n        )\n        measured_ansatz = cast(\n            QuantumCircuit, self.ansatz.measure_all(inplace=False)\n        )\n        sampled = sampler.run([(measured_ansatz, bound_params)]).result()\n\n        out.sampled = sampled\n\n        meas = cast(SamplerData, sampled[0].data).meas\n        out.meas_counts = meas.get_counts()\n\n        if self.app is not None:\n            out.interpreted = self.app.interpreted_meas(meas)\n\n    return out\n</code></pre>"},{"location":"reference/q3as.algo/VQE/#q3as.algo.VQE.send","title":"<code>send(api, run_options=RunOptions())</code>","text":"<p>Send the VQE job to the API</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>def send(self, api: Client, run_options: RunOptions = RunOptions()) -&gt; Job:\n    \"\"\"\n    Send the VQE job to the API\n    \"\"\"\n    return api.create_job(\n        q3as.api.JobRequest(\n            input=q3as.encoding.EncodedVQE.encode(self), run_options=run_options\n        )\n    )\n</code></pre>"},{"location":"reference/q3as.algo/VQEBuilder/","title":"VQEBuilder","text":"Source code in <code>q3as/algo/vqe.py</code> <pre><code>class VQEBuilder:\n    _app: Optional[Application] = None\n    _ansatz: Optional[Union[QuantumCircuit, AnsatzCallback]] = EfficientSU2()\n    _observables: Optional[ObservablesArrayLike] = None\n    _initial_params: Optional[ArrayLike] = None\n    _optimizer: Optimizer = COBYLA()\n    _maxiter: int = 1000\n\n    def app(self, app: Application):\n        \"\"\"\n        Set the `Application` to use for interpretation of results\n        \"\"\"\n        self._app = app\n        return self\n\n    def ansatz(\n        self,\n        qc: Union[QuantumCircuit, AnsatzCallback],\n    ) -&gt; VQEBuilder:\n        \"\"\"\n        Set the ansatz to use for the VQE.\n        This can either be a QuantumCircuit or a callback that takes the observables as argument and returns a QuantumCircuit.\n        This defaults to the EfficientSU2 ansatz.\n        \"\"\"\n        self._ansatz = qc\n        return self\n\n    def observables(self, obs: ObservablesArrayLike) -&gt; VQEBuilder:\n        \"\"\"\n        Set the observables to estimate. E.g. the Hamiltonian of the system.\n        If no observables are given, the Hamiltonian of the application is used\n        \"\"\"\n        self._observables = obs\n        return self\n\n    def initial_params(self, params: ArrayLike) -&gt; VQEBuilder:\n        \"\"\"\n        Set the initial parameters of the ansatz. If no parameters are given, the initial parameters are set to 0.\n        \"\"\"\n        self._initial_params = params\n        return self\n\n    def optimizer(self, opt: Optimizer) -&gt; VQEBuilder:\n        \"\"\"\n        Set the optimizer to use for the VQE. This defaults to COBYLA.\n        \"\"\"\n        self._optimizer = opt\n        return self\n\n    def maxiter(self, maxiter: int) -&gt; VQEBuilder:\n        \"\"\"\n        Set the maximum number of iterations for the VQE. This defaults to 1000.\n        \"\"\"\n        self._maxiter = maxiter\n        return self\n\n    def build(self) -&gt; VQE:\n        \"\"\"\n        Build the VQE instance\n        \"\"\"\n        if self._observables is None:\n            if self._app is not None:\n                observables = self._app.hamiltonian()\n            else:\n                raise ValueError(\"Observables are required\")\n        else:\n            observables = self._observables\n        observables = ObservablesArray.coerce(observables)\n\n        if self._ansatz is None:\n            raise ValueError(\"Ansatz is required\")\n        if isinstance(self._ansatz, QuantumCircuit):\n            ansatz = self._ansatz\n        else:\n            ansatz = self._ansatz(observables)\n\n        if self._initial_params is not None:\n            _initial_params = np.array(self._initial_params)\n            if len(_initial_params) != ansatz.num_parameters:\n                raise ValueError(\"Initial parameters must match ansatz\")\n        else:\n            _initial_params = np.zeros(ansatz.num_parameters)\n\n        return VQE(\n            app=self._app,\n            ansatz=ansatz,\n            observables=observables,\n            initial_params=_initial_params,\n            optimizer=self._optimizer,\n            maxiter=self._maxiter,\n        )\n\n    def run(\n        self,\n        estimator: Estimator,\n        sampler: Optional[Sampler] = None,\n        callback: Optional[Callable[[VQEIteration], None]] = None,\n    ) -&gt; VQEResult:\n        \"\"\"\n        Run the VQE\n        \"\"\"\n        return self.build().run(estimator, sampler, callback)\n\n    def send(self, api: Client, estimator: RunOptions = RunOptions()) -&gt; Job:\n        \"\"\"\n        Send the VQE job to the API\n        \"\"\"\n        return self.build().send(api, estimator)\n</code></pre>"},{"location":"reference/q3as.algo/VQEBuilder/#q3as.algo.VQEBuilder.ansatz","title":"<code>ansatz(qc)</code>","text":"<p>Set the ansatz to use for the VQE. This can either be a QuantumCircuit or a callback that takes the observables as argument and returns a QuantumCircuit. This defaults to the EfficientSU2 ansatz.</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>def ansatz(\n    self,\n    qc: Union[QuantumCircuit, AnsatzCallback],\n) -&gt; VQEBuilder:\n    \"\"\"\n    Set the ansatz to use for the VQE.\n    This can either be a QuantumCircuit or a callback that takes the observables as argument and returns a QuantumCircuit.\n    This defaults to the EfficientSU2 ansatz.\n    \"\"\"\n    self._ansatz = qc\n    return self\n</code></pre>"},{"location":"reference/q3as.algo/VQEBuilder/#q3as.algo.VQEBuilder.app","title":"<code>app(app)</code>","text":"<p>Set the <code>Application</code> to use for interpretation of results</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>def app(self, app: Application):\n    \"\"\"\n    Set the `Application` to use for interpretation of results\n    \"\"\"\n    self._app = app\n    return self\n</code></pre>"},{"location":"reference/q3as.algo/VQEBuilder/#q3as.algo.VQEBuilder.build","title":"<code>build()</code>","text":"<p>Build the VQE instance</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>def build(self) -&gt; VQE:\n    \"\"\"\n    Build the VQE instance\n    \"\"\"\n    if self._observables is None:\n        if self._app is not None:\n            observables = self._app.hamiltonian()\n        else:\n            raise ValueError(\"Observables are required\")\n    else:\n        observables = self._observables\n    observables = ObservablesArray.coerce(observables)\n\n    if self._ansatz is None:\n        raise ValueError(\"Ansatz is required\")\n    if isinstance(self._ansatz, QuantumCircuit):\n        ansatz = self._ansatz\n    else:\n        ansatz = self._ansatz(observables)\n\n    if self._initial_params is not None:\n        _initial_params = np.array(self._initial_params)\n        if len(_initial_params) != ansatz.num_parameters:\n            raise ValueError(\"Initial parameters must match ansatz\")\n    else:\n        _initial_params = np.zeros(ansatz.num_parameters)\n\n    return VQE(\n        app=self._app,\n        ansatz=ansatz,\n        observables=observables,\n        initial_params=_initial_params,\n        optimizer=self._optimizer,\n        maxiter=self._maxiter,\n    )\n</code></pre>"},{"location":"reference/q3as.algo/VQEBuilder/#q3as.algo.VQEBuilder.initial_params","title":"<code>initial_params(params)</code>","text":"<p>Set the initial parameters of the ansatz. If no parameters are given, the initial parameters are set to 0.</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>def initial_params(self, params: ArrayLike) -&gt; VQEBuilder:\n    \"\"\"\n    Set the initial parameters of the ansatz. If no parameters are given, the initial parameters are set to 0.\n    \"\"\"\n    self._initial_params = params\n    return self\n</code></pre>"},{"location":"reference/q3as.algo/VQEBuilder/#q3as.algo.VQEBuilder.maxiter","title":"<code>maxiter(maxiter)</code>","text":"<p>Set the maximum number of iterations for the VQE. This defaults to 1000.</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>def maxiter(self, maxiter: int) -&gt; VQEBuilder:\n    \"\"\"\n    Set the maximum number of iterations for the VQE. This defaults to 1000.\n    \"\"\"\n    self._maxiter = maxiter\n    return self\n</code></pre>"},{"location":"reference/q3as.algo/VQEBuilder/#q3as.algo.VQEBuilder.observables","title":"<code>observables(obs)</code>","text":"<p>Set the observables to estimate. E.g. the Hamiltonian of the system. If no observables are given, the Hamiltonian of the application is used</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>def observables(self, obs: ObservablesArrayLike) -&gt; VQEBuilder:\n    \"\"\"\n    Set the observables to estimate. E.g. the Hamiltonian of the system.\n    If no observables are given, the Hamiltonian of the application is used\n    \"\"\"\n    self._observables = obs\n    return self\n</code></pre>"},{"location":"reference/q3as.algo/VQEBuilder/#q3as.algo.VQEBuilder.optimizer","title":"<code>optimizer(opt)</code>","text":"<p>Set the optimizer to use for the VQE. This defaults to COBYLA.</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>def optimizer(self, opt: Optimizer) -&gt; VQEBuilder:\n    \"\"\"\n    Set the optimizer to use for the VQE. This defaults to COBYLA.\n    \"\"\"\n    self._optimizer = opt\n    return self\n</code></pre>"},{"location":"reference/q3as.algo/VQEBuilder/#q3as.algo.VQEBuilder.run","title":"<code>run(estimator, sampler=None, callback=None)</code>","text":"<p>Run the VQE</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>def run(\n    self,\n    estimator: Estimator,\n    sampler: Optional[Sampler] = None,\n    callback: Optional[Callable[[VQEIteration], None]] = None,\n) -&gt; VQEResult:\n    \"\"\"\n    Run the VQE\n    \"\"\"\n    return self.build().run(estimator, sampler, callback)\n</code></pre>"},{"location":"reference/q3as.algo/VQEBuilder/#q3as.algo.VQEBuilder.send","title":"<code>send(api, estimator=RunOptions())</code>","text":"<p>Send the VQE job to the API</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>def send(self, api: Client, estimator: RunOptions = RunOptions()) -&gt; Job:\n    \"\"\"\n    Send the VQE job to the API\n    \"\"\"\n    return self.build().send(api, estimator)\n</code></pre>"},{"location":"reference/q3as.algo/VQEIteration/","title":"VQEIteration","text":"<p>The result of a an iteration of VQE</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>@dataclass\nclass VQEIteration:\n    \"\"\"\n    The result of a an iteration of VQE\n    \"\"\"\n\n    iter: int\n    \"The number of the iteration\"\n    cost: float\n    \"The value of the cost function of the iteration\"\n    params: np.ndarray\n    \"The parameters of the ansatz of the iteration\"\n    estimated: PrimitiveResult[PubResult]\n    \"The result of the estimation\"\n    best: bool = False\n    \"Whether this iteration is the best so far\"\n</code></pre>"},{"location":"reference/q3as.algo/VQEIteration/#q3as.algo.VQEIteration.best","title":"<code>best: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether this iteration is the best so far</p>"},{"location":"reference/q3as.algo/VQEIteration/#q3as.algo.VQEIteration.cost","title":"<code>cost: float</code>  <code>instance-attribute</code>","text":"<p>The value of the cost function of the iteration</p>"},{"location":"reference/q3as.algo/VQEIteration/#q3as.algo.VQEIteration.estimated","title":"<code>estimated: PrimitiveResult[PubResult]</code>  <code>instance-attribute</code>","text":"<p>The result of the estimation</p>"},{"location":"reference/q3as.algo/VQEIteration/#q3as.algo.VQEIteration.iter","title":"<code>iter: int</code>  <code>instance-attribute</code>","text":"<p>The number of the iteration</p>"},{"location":"reference/q3as.algo/VQEIteration/#q3as.algo.VQEIteration.params","title":"<code>params: np.ndarray</code>  <code>instance-attribute</code>","text":"<p>The parameters of the ansatz of the iteration</p>"},{"location":"reference/q3as.algo/VQEResult/","title":"VQEResult","text":"Source code in <code>q3as/algo/vqe.py</code> <pre><code>@dataclass\nclass VQEResult:\n    params: np.ndarray\n    \"The parameters of the best iteration\"\n    iter: int = 0\n    \"The number of iterations\"\n    reason: HaltReason = HaltReason.INTERRUPT\n    \"The reason why the optimization stopped\"\n    cost: Optional[float] = None\n    \"The value of the cost function of the best iteration\"\n    estimated: Optional[PrimitiveResult[PubResult]] = None\n    \"The result of the estimation of the best iteration\"\n    sampled: Optional[PrimitiveResult[SamplerPubResult]] = None\n    \"The result of the sampling\"\n    meas_counts: Optional[Dict[str, int]] = None\n    \"The bit string counts after sampling\"\n    interpreted: Optional[List[Tuple[Any, int]]] = None\n    \"The interpreted results of the sampling as defined by the application if given\"\n\n    def most_sampled(self) -&gt; Optional[Any]:\n        \"\"\"\n        Get the the most sampled value from the results.\n        This is the interpreted value as defined by the application if given or otherwise the bitstring\n        \"\"\"\n        samples = None\n        if self.interpreted is not None:\n            samples = [(count, value) for value, count in self.interpreted]\n        elif self.meas_counts is not None:\n            samples = [\n                (count, bitstring) for bitstring, count in self.meas_counts.items()\n            ]\n        max_sample = max(samples, key=lambda x: x[0]) if samples is not None else None\n        if max_sample is not None:\n            return max_sample[1]\n        return None\n</code></pre>"},{"location":"reference/q3as.algo/VQEResult/#q3as.algo.VQEResult.cost","title":"<code>cost: Optional[float] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The value of the cost function of the best iteration</p>"},{"location":"reference/q3as.algo/VQEResult/#q3as.algo.VQEResult.estimated","title":"<code>estimated: Optional[PrimitiveResult[PubResult]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The result of the estimation of the best iteration</p>"},{"location":"reference/q3as.algo/VQEResult/#q3as.algo.VQEResult.interpreted","title":"<code>interpreted: Optional[List[Tuple[Any, int]]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The interpreted results of the sampling as defined by the application if given</p>"},{"location":"reference/q3as.algo/VQEResult/#q3as.algo.VQEResult.iter","title":"<code>iter: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of iterations</p>"},{"location":"reference/q3as.algo/VQEResult/#q3as.algo.VQEResult.meas_counts","title":"<code>meas_counts: Optional[Dict[str, int]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The bit string counts after sampling</p>"},{"location":"reference/q3as.algo/VQEResult/#q3as.algo.VQEResult.params","title":"<code>params: np.ndarray</code>  <code>instance-attribute</code>","text":"<p>The parameters of the best iteration</p>"},{"location":"reference/q3as.algo/VQEResult/#q3as.algo.VQEResult.reason","title":"<code>reason: HaltReason = HaltReason.INTERRUPT</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The reason why the optimization stopped</p>"},{"location":"reference/q3as.algo/VQEResult/#q3as.algo.VQEResult.sampled","title":"<code>sampled: Optional[PrimitiveResult[SamplerPubResult]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The result of the sampling</p>"},{"location":"reference/q3as.algo/VQEResult/#q3as.algo.VQEResult.most_sampled","title":"<code>most_sampled()</code>","text":"<p>Get the the most sampled value from the results. This is the interpreted value as defined by the application if given or otherwise the bitstring</p> Source code in <code>q3as/algo/vqe.py</code> <pre><code>def most_sampled(self) -&gt; Optional[Any]:\n    \"\"\"\n    Get the the most sampled value from the results.\n    This is the interpreted value as defined by the application if given or otherwise the bitstring\n    \"\"\"\n    samples = None\n    if self.interpreted is not None:\n        samples = [(count, value) for value, count in self.interpreted]\n    elif self.meas_counts is not None:\n        samples = [\n            (count, bitstring) for bitstring, count in self.meas_counts.items()\n        ]\n    max_sample = max(samples, key=lambda x: x[0]) if samples is not None else None\n    if max_sample is not None:\n        return max_sample[1]\n    return None\n</code></pre>"},{"location":"reference/q3as.app/Application/","title":"Application","text":"<p>               Bases: <code>ABC</code>, <code>Generic[Encoded, State]</code></p> Source code in <code>q3as/app/application.py</code> <pre><code>class Application(ABC, Generic[Encoded, State]):\n    @abstractmethod\n    def name(self) -&gt; ApplicationName:\n        pass\n\n    @abstractmethod\n    def encode(self) -&gt; Encoded:\n        pass\n\n    @classmethod\n    @abstractmethod\n    def decode(cls, encoded: Encoded) -&gt; Application:\n        pass\n\n    @classmethod\n    def validate_encoded(cls, encoded: Any) -&gt; Encoded:\n        return encoded\n\n    @classmethod\n    def decode_any(cls, encoded: Any) -&gt; Application:\n        return cls.decode(cls.validate_encoded(encoded))\n\n    @abstractmethod\n    def hamiltonian(self) -&gt; ObservablesArrayLike:\n        pass\n\n    @abstractmethod\n    def interpret(self, bit_string: BitString) -&gt; State:\n        pass\n\n    def interpreted_meas(self, meas: BitArray) -&gt; List[Tuple[State, int]]:\n        out = {}\n        for state, count in meas.get_counts().items():\n            interpreted = self.interpret(BitString(state))\n            cur_count = out.get(interpreted, 0)\n            out[interpreted] = cur_count + count\n        return list(out.items())\n</code></pre>"},{"location":"reference/q3as.app/Maxcut/","title":"Maxcut","text":"<p>               Bases: <code>Application[EdgesInput, MaxcutOutput]</code></p> Source code in <code>q3as/app/maxcut.py</code> <pre><code>class Maxcut(Application[EdgesInput, MaxcutOutput]):\n    def __init__(self, edges: EdgesInput):\n        \"\"\"\n        Create a new Maxcut application. This takes in a list of edges, where each edge is a tuple of two nodes and a weight. Nodes can be either strings or integers\n        \"\"\"\n        self.edges, self.nodes = Maxcut._normalize_edges(edges)\n\n    @classmethod\n    def _normalize_edges(\n        cls, input: EdgesInput\n    ) -&gt; Tuple[Dict[Tuple[int, int], float], List[InputNode]]:\n        edges = []\n        nodes = set()\n        for edge in input:\n            if len(edge) == 3:\n                new_edge = edge\n            elif len(edge) == 2:\n                new_edge = (edge[0], edge[1], 1.0)\n            else:\n                raise ValueError(\"Invalid edge format\")\n            edges.append(new_edge)\n            nodes.add(new_edge[0])\n            nodes.add(new_edge[1])\n        nodes = list(nodes)\n        remap = {x: i for i, x in enumerate(nodes)}\n        return (\n            {(remap[e[0]], remap[e[1]]): e[2] for e in edges},\n            nodes,\n        )\n\n    def name(self) -&gt; ApplicationName:\n        return \"maxcut\"\n\n    def encode(self) -&gt; EdgesInput:\n        return [(self.nodes[i], self.nodes[j], w) for (i, j), w in self.edges.items()]\n\n    @classmethod\n    def decode(cls, encoded: EdgesInput) -&gt; Maxcut:\n        return cls(encoded)\n\n    def hamiltonian(self) -&gt; ObservablesArrayLike:\n        pauli_list = []\n        for (i, j), w in self.edges.items():\n            paulis = [\"I\"] * len(self.nodes)\n            paulis[i], paulis[j] = \"Z\", \"Z\"\n            pauli_list.append((\"\".join(paulis)[::-1], w))\n        return SparsePauliOp.from_list(pauli_list)\n\n    def interpret(self, bit_string: BitString) -&gt; MaxcutOutput:\n        \"\"\"\n        Interpret the bit string as a solution to the Maxcut problem. This will return the nodes in S and T, as well as the edges that need to be cut\n        \"\"\"\n        s = set()\n        t = set()\n        for i, bit in enumerate(np.flip(bit_string.to_list())):\n            if bit:\n                s.add(i)\n            else:\n                t.add(i)\n        edges = []\n        for u in s:\n            for v in t:\n                w = self.edges.get((u, v), self.edges.get((v, u)))\n                if w is not None:\n                    edges.append((self.nodes[u], self.nodes[v], w))\n        s = sorted([self.nodes[i] for i in s])\n        t = sorted([self.nodes[i] for i in t])\n        return MaxcutOutput(s=s, t=t, edges=edges)\n</code></pre>"},{"location":"reference/q3as.app/Maxcut/#q3as.app.Maxcut.__init__","title":"<code>__init__(edges)</code>","text":"<p>Create a new Maxcut application. This takes in a list of edges, where each edge is a tuple of two nodes and a weight. Nodes can be either strings or integers</p> Source code in <code>q3as/app/maxcut.py</code> <pre><code>def __init__(self, edges: EdgesInput):\n    \"\"\"\n    Create a new Maxcut application. This takes in a list of edges, where each edge is a tuple of two nodes and a weight. Nodes can be either strings or integers\n    \"\"\"\n    self.edges, self.nodes = Maxcut._normalize_edges(edges)\n</code></pre>"},{"location":"reference/q3as.app/Maxcut/#q3as.app.Maxcut.interpret","title":"<code>interpret(bit_string)</code>","text":"<p>Interpret the bit string as a solution to the Maxcut problem. This will return the nodes in S and T, as well as the edges that need to be cut</p> Source code in <code>q3as/app/maxcut.py</code> <pre><code>def interpret(self, bit_string: BitString) -&gt; MaxcutOutput:\n    \"\"\"\n    Interpret the bit string as a solution to the Maxcut problem. This will return the nodes in S and T, as well as the edges that need to be cut\n    \"\"\"\n    s = set()\n    t = set()\n    for i, bit in enumerate(np.flip(bit_string.to_list())):\n        if bit:\n            s.add(i)\n        else:\n            t.add(i)\n    edges = []\n    for u in s:\n        for v in t:\n            w = self.edges.get((u, v), self.edges.get((v, u)))\n            if w is not None:\n                edges.append((self.nodes[u], self.nodes[v], w))\n    s = sorted([self.nodes[i] for i in s])\n    t = sorted([self.nodes[i] for i in t])\n    return MaxcutOutput(s=s, t=t, edges=edges)\n</code></pre>"},{"location":"reference/q3as.app/MaxcutOutput/","title":"MaxcutOutput","text":"<p>               Bases: <code>BaseModel</code></p> <p>The output of the Maxcut application</p> Source code in <code>q3as/app/maxcut.py</code> <pre><code>class MaxcutOutput(BaseModel):\n    \"\"\"\n    The output of the Maxcut application\n    \"\"\"\n\n    s: List[InputNode]\n    \"Nodes in S\"\n    t: List[InputNode]\n    \"Nodes in T\"\n    edges: List[Tuple[InputNode, InputNode, float]]\n    \"The list of edges that need to be cut\"\n\n    def __hash__(self):\n        return hash(self.model_dump_json())\n</code></pre>"},{"location":"reference/q3as.app/MaxcutOutput/#q3as.app.MaxcutOutput.edges","title":"<code>edges: List[Tuple[InputNode, InputNode, float]]</code>  <code>instance-attribute</code>","text":"<p>The list of edges that need to be cut</p>"},{"location":"reference/q3as.app/MaxcutOutput/#q3as.app.MaxcutOutput.s","title":"<code>s: List[InputNode]</code>  <code>instance-attribute</code>","text":"<p>Nodes in S</p>"},{"location":"reference/q3as.app/MaxcutOutput/#q3as.app.MaxcutOutput.t","title":"<code>t: List[InputNode]</code>  <code>instance-attribute</code>","text":"<p>Nodes in T</p>"},{"location":"reference/q3as.app/Qubo/","title":"Qubo","text":"<p>               Bases: <code>Application[EncodedQuadraticProgram, frozenset[Tuple[str, float]]]</code></p> Source code in <code>q3as/app/qubo.py</code> <pre><code>class Qubo(Application[EncodedQuadraticProgram, frozenset[Tuple[str, float]]]):\n    def __init__(self, qp: QuadraticProgram):\n        \"\"\"\n        Create a new QUBO application.\n        \"\"\"\n        self.program = qp\n        self.converter = QuadraticProgramToQubo()\n        self.converted = self.converter.convert(qp)\n\n    def name(self) -&gt; ApplicationName:\n        return \"qubo\"\n\n    def encode(self) -&gt; EncodedQuadraticProgram:\n        return EncodedQuadraticProgram.encode(self.program)\n\n    @classmethod\n    def validate_encoded(cls, encoded: Any) -&gt; EncodedQuadraticProgram:\n        return EncodedQuadraticProgram.model_validate(encoded)\n\n    @classmethod\n    def decode(cls, encoded: EncodedQuadraticProgram) -&gt; Qubo:\n        return Qubo(EncodedQuadraticProgram.decode(encoded))\n\n    def hamiltonian(self):\n        \"\"\"\n        Return the Hamiltonian of the QUBO problem.\n        \"\"\"\n        return self.converted.to_ising()[0]\n\n    def interpret(self, bit_string: BitString) -&gt; frozenset[Tuple[str, float]]:\n        \"\"\"\n        Interpret the bit string as a solution to the QUBO problem. This will return a list of pairs of variable names and their assigned values\n        \"\"\"\n        values = self.converter.interpret(np.flip(bit_string.to_list()))\n        return frozenset(\n            [\n                (name, float(values[index]))\n                for name, index in self.program.variables_index.items()\n            ]\n        )\n</code></pre>"},{"location":"reference/q3as.app/Qubo/#q3as.app.Qubo.__init__","title":"<code>__init__(qp)</code>","text":"<p>Create a new QUBO application.</p> Source code in <code>q3as/app/qubo.py</code> <pre><code>def __init__(self, qp: QuadraticProgram):\n    \"\"\"\n    Create a new QUBO application.\n    \"\"\"\n    self.program = qp\n    self.converter = QuadraticProgramToQubo()\n    self.converted = self.converter.convert(qp)\n</code></pre>"},{"location":"reference/q3as.app/Qubo/#q3as.app.Qubo.hamiltonian","title":"<code>hamiltonian()</code>","text":"<p>Return the Hamiltonian of the QUBO problem.</p> Source code in <code>q3as/app/qubo.py</code> <pre><code>def hamiltonian(self):\n    \"\"\"\n    Return the Hamiltonian of the QUBO problem.\n    \"\"\"\n    return self.converted.to_ising()[0]\n</code></pre>"},{"location":"reference/q3as.app/Qubo/#q3as.app.Qubo.interpret","title":"<code>interpret(bit_string)</code>","text":"<p>Interpret the bit string as a solution to the QUBO problem. This will return a list of pairs of variable names and their assigned values</p> Source code in <code>q3as/app/qubo.py</code> <pre><code>def interpret(self, bit_string: BitString) -&gt; frozenset[Tuple[str, float]]:\n    \"\"\"\n    Interpret the bit string as a solution to the QUBO problem. This will return a list of pairs of variable names and their assigned values\n    \"\"\"\n    values = self.converter.interpret(np.flip(bit_string.to_list()))\n    return frozenset(\n        [\n            (name, float(values[index]))\n            for name, index in self.program.variables_index.items()\n        ]\n    )\n</code></pre>"},{"location":"reference/q3as.quadratic/Constraint/","title":"Constraint","text":"<p>               Bases: <code>QuadraticProgramElement</code></p> <p>Abstract Constraint Class.</p> Source code in <code>q3as/quadratic/problems/constraint.py</code> <pre><code>class Constraint(QuadraticProgramElement):\n    \"\"\"Abstract Constraint Class.\"\"\"\n\n    Sense = ConstraintSense\n\n    def __init__(\n        self, quadratic_program: Any, name: str, sense: ConstraintSense, rhs: float\n    ) -&gt; None:\n        \"\"\"Initializes the constraint.\n\n        Args:\n            quadratic_program: The parent QuadraticProgram.\n            name: The name of the constraint.\n            sense: The sense of the constraint.\n            rhs: The right-hand-side of the constraint.\n        \"\"\"\n        super().__init__(quadratic_program)\n        self._name = name\n        self._sense = sense\n        self._rhs = rhs\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Returns the name of the constraint.\n\n        Returns:\n            The name of the constraint.\n        \"\"\"\n        return self._name\n\n    @property\n    def sense(self) -&gt; ConstraintSense:\n        \"\"\"Returns the sense of the constraint.\n\n        Returns:\n            The sense of the constraint.\n        \"\"\"\n        return self._sense\n\n    @sense.setter\n    def sense(self, sense: ConstraintSense) -&gt; None:\n        \"\"\"Sets the sense of the constraint.\n\n        Args:\n            sense: The sense of the constraint.\n        \"\"\"\n        self._sense = sense\n\n    @property\n    def rhs(self) -&gt; float:\n        \"\"\"Returns the right-hand-side of the constraint.\n\n        Returns:\n            The right-hand-side of the constraint.\n        \"\"\"\n        return self._rhs\n\n    @rhs.setter\n    def rhs(self, rhs: float) -&gt; None:\n        \"\"\"Sets the right-hand-side of the constraint.\n\n        Args:\n            rhs: The right-hand-side of the constraint.\n        \"\"\"\n        self._rhs = rhs\n\n    @abstractmethod\n    def evaluate(self, x: Union[ndarray, List, Dict[Union[int, str], float]]) -&gt; float:\n        \"\"\"Evaluate left-hand-side of constraint for given values of variables.\n\n        Args:\n            x: The values to be used for the variables.\n\n        Returns:\n            The left-hand-side of the constraint.\n        \"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"reference/q3as.quadratic/Constraint/#q3as.quadratic.Constraint.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns the name of the constraint.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the constraint.</p>"},{"location":"reference/q3as.quadratic/Constraint/#q3as.quadratic.Constraint.rhs","title":"<code>rhs: float</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the right-hand-side of the constraint.</p> <p>Returns:</p> Type Description <code>float</code> <p>The right-hand-side of the constraint.</p>"},{"location":"reference/q3as.quadratic/Constraint/#q3as.quadratic.Constraint.sense","title":"<code>sense: ConstraintSense</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the sense of the constraint.</p> <p>Returns:</p> Type Description <code>ConstraintSense</code> <p>The sense of the constraint.</p>"},{"location":"reference/q3as.quadratic/Constraint/#q3as.quadratic.Constraint.__init__","title":"<code>__init__(quadratic_program, name, sense, rhs)</code>","text":"<p>Initializes the constraint.</p> <p>Parameters:</p> Name Type Description Default <code>quadratic_program</code> <code>Any</code> <p>The parent QuadraticProgram.</p> required <code>name</code> <code>str</code> <p>The name of the constraint.</p> required <code>sense</code> <code>ConstraintSense</code> <p>The sense of the constraint.</p> required <code>rhs</code> <code>float</code> <p>The right-hand-side of the constraint.</p> required Source code in <code>q3as/quadratic/problems/constraint.py</code> <pre><code>def __init__(\n    self, quadratic_program: Any, name: str, sense: ConstraintSense, rhs: float\n) -&gt; None:\n    \"\"\"Initializes the constraint.\n\n    Args:\n        quadratic_program: The parent QuadraticProgram.\n        name: The name of the constraint.\n        sense: The sense of the constraint.\n        rhs: The right-hand-side of the constraint.\n    \"\"\"\n    super().__init__(quadratic_program)\n    self._name = name\n    self._sense = sense\n    self._rhs = rhs\n</code></pre>"},{"location":"reference/q3as.quadratic/Constraint/#q3as.quadratic.Constraint.evaluate","title":"<code>evaluate(x)</code>  <code>abstractmethod</code>","text":"<p>Evaluate left-hand-side of constraint for given values of variables.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ndarray, List, Dict[Union[int, str], float]]</code> <p>The values to be used for the variables.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The left-hand-side of the constraint.</p> Source code in <code>q3as/quadratic/problems/constraint.py</code> <pre><code>@abstractmethod\ndef evaluate(self, x: Union[ndarray, List, Dict[Union[int, str], float]]) -&gt; float:\n    \"\"\"Evaluate left-hand-side of constraint for given values of variables.\n\n    Args:\n        x: The values to be used for the variables.\n\n    Returns:\n        The left-hand-side of the constraint.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/q3as.quadratic/LinearConstraint/","title":"LinearConstraint","text":"<p>               Bases: <code>Constraint</code></p> <p>Representation of a linear constraint.</p> Source code in <code>q3as/quadratic/problems/linear_constraint.py</code> <pre><code>class LinearConstraint(Constraint):\n    \"\"\"Representation of a linear constraint.\"\"\"\n\n    # Note: added, duplicating in effect that in Constraint, to avoid issues with Sphinx\n    Sense = ConstraintSense\n\n    def __init__(\n        self,\n        quadratic_program: Any,\n        name: str,\n        linear: Union[ndarray, spmatrix, List[float], Dict[Union[str, int], float]],\n        sense: ConstraintSense,\n        rhs: float,\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            quadratic_program: The parent quadratic program.\n            name: The name of the constraint.\n            linear: The coefficients specifying the linear constraint.\n            sense: The sense of the constraint.\n            rhs: The right-hand-side of the constraint.\n        \"\"\"\n        super().__init__(quadratic_program, name, sense, rhs)\n        self._linear = LinearExpression(quadratic_program, linear)\n\n    @property\n    def linear(self) -&gt; LinearExpression:\n        \"\"\"Returns the linear expression corresponding to the left-hand-side of the constraint.\n\n        Returns:\n            The left-hand-side linear expression.\n        \"\"\"\n        return self._linear\n\n    @linear.setter\n    def linear(\n        self,\n        linear: Union[ndarray, spmatrix, List[float], Dict[Union[str, int], float]],\n    ) -&gt; None:\n        \"\"\"Sets the linear expression corresponding to the left-hand-side of the constraint.\n        The coefficients can either be given by an array, a (sparse) 1d matrix, a list or a\n        dictionary.\n\n        Args:\n            linear: The linear coefficients of the left-hand-side.\n        \"\"\"\n        self._linear = LinearExpression(self.quadratic_program, linear)\n\n    def evaluate(self, x: Union[ndarray, List, Dict[Union[int, str], float]]) -&gt; float:\n        \"\"\"Evaluate the left-hand-side of the constraint.\n\n        Args:\n            x: The values of the variables to be evaluated.\n\n        Returns:\n            The left-hand-side of the constraint given the variable values.\n        \"\"\"\n        return self.linear.evaluate(x)\n\n    def __repr__(self):\n        # pylint: disable=cyclic-import\n        from ..translators.prettyprint import expr2str, DEFAULT_TRUNCATE\n\n        lhs = expr2str(linear=self.linear, truncate=DEFAULT_TRUNCATE)\n        return f\"&lt;{self.__class__.__name__}: {lhs} {self.sense.label} {self.rhs} '{self.name}'&gt;\"\n\n    def __str__(self):\n        # pylint: disable=cyclic-import\n        from ..translators.prettyprint import expr2str\n\n        lhs = expr2str(linear=self.linear)\n        return f\"{lhs} {self.sense.label} {self.rhs} '{self.name}'\"\n</code></pre>"},{"location":"reference/q3as.quadratic/LinearConstraint/#q3as.quadratic.LinearConstraint.linear","title":"<code>linear: LinearExpression</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the linear expression corresponding to the left-hand-side of the constraint.</p> <p>Returns:</p> Type Description <code>LinearExpression</code> <p>The left-hand-side linear expression.</p>"},{"location":"reference/q3as.quadratic/LinearConstraint/#q3as.quadratic.LinearConstraint.__init__","title":"<code>__init__(quadratic_program, name, linear, sense, rhs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>quadratic_program</code> <code>Any</code> <p>The parent quadratic program.</p> required <code>name</code> <code>str</code> <p>The name of the constraint.</p> required <code>linear</code> <code>Union[ndarray, spmatrix, List[float], Dict[Union[str, int], float]]</code> <p>The coefficients specifying the linear constraint.</p> required <code>sense</code> <code>ConstraintSense</code> <p>The sense of the constraint.</p> required <code>rhs</code> <code>float</code> <p>The right-hand-side of the constraint.</p> required Source code in <code>q3as/quadratic/problems/linear_constraint.py</code> <pre><code>def __init__(\n    self,\n    quadratic_program: Any,\n    name: str,\n    linear: Union[ndarray, spmatrix, List[float], Dict[Union[str, int], float]],\n    sense: ConstraintSense,\n    rhs: float,\n) -&gt; None:\n    \"\"\"\n    Args:\n        quadratic_program: The parent quadratic program.\n        name: The name of the constraint.\n        linear: The coefficients specifying the linear constraint.\n        sense: The sense of the constraint.\n        rhs: The right-hand-side of the constraint.\n    \"\"\"\n    super().__init__(quadratic_program, name, sense, rhs)\n    self._linear = LinearExpression(quadratic_program, linear)\n</code></pre>"},{"location":"reference/q3as.quadratic/LinearConstraint/#q3as.quadratic.LinearConstraint.evaluate","title":"<code>evaluate(x)</code>","text":"<p>Evaluate the left-hand-side of the constraint.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ndarray, List, Dict[Union[int, str], float]]</code> <p>The values of the variables to be evaluated.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The left-hand-side of the constraint given the variable values.</p> Source code in <code>q3as/quadratic/problems/linear_constraint.py</code> <pre><code>def evaluate(self, x: Union[ndarray, List, Dict[Union[int, str], float]]) -&gt; float:\n    \"\"\"Evaluate the left-hand-side of the constraint.\n\n    Args:\n        x: The values of the variables to be evaluated.\n\n    Returns:\n        The left-hand-side of the constraint given the variable values.\n    \"\"\"\n    return self.linear.evaluate(x)\n</code></pre>"},{"location":"reference/q3as.quadratic/LinearExpression/","title":"LinearExpression","text":"<p>               Bases: <code>QuadraticProgramElement</code></p> <p>Representation of a linear expression by its coefficients.</p> Source code in <code>q3as/quadratic/problems/linear_expression.py</code> <pre><code>class LinearExpression(QuadraticProgramElement):\n    \"\"\"Representation of a linear expression by its coefficients.\"\"\"\n\n    def __init__(\n        self,\n        quadratic_program: Any,\n        coefficients: Union[\n            ndarray, spmatrix, List[float], Dict[Union[int, str], float]\n        ],\n    ) -&gt; None:\n        \"\"\"Creates a new linear expression.\n\n        The linear expression can be defined via an array, a list, a sparse matrix, or a dictionary\n        that uses variable names or indices as keys and stores the values internally as a\n        dok_matrix.\n\n        Args:\n            quadratic_program: The parent QuadraticProgram.\n            coefficients: The (sparse) representation of the coefficients.\n\n        \"\"\"\n        super().__init__(quadratic_program)\n        self.coefficients = coefficients\n\n    def __getitem__(self, i: Union[int, str]) -&gt; float:\n        \"\"\"Returns the i-th coefficient where i can be a variable name or index.\n\n        Args:\n            i: the index or name of the variable corresponding to the coefficient.\n\n        Returns:\n            The coefficient corresponding to the addressed variable.\n        \"\"\"\n        if isinstance(i, str):\n            i = self.quadratic_program.variables_index[i]\n        return self.coefficients[0, i]\n\n    def __setitem__(self, i: Union[int, str], value: float) -&gt; None:\n        if isinstance(i, str):\n            i = self.quadratic_program.variables_index[i]\n        self._coefficients[0, i] = value\n\n    def _coeffs_to_dok_matrix(\n        self, coefficients: Union[ndarray, spmatrix, List, Dict[Union[int, str], float]]\n    ) -&gt; dok_matrix:\n        \"\"\"Maps given 1d-coefficients to a dok_matrix.\n\n        Args:\n            coefficients: The 1d-coefficients to be mapped.\n\n        Returns:\n            The given 1d-coefficients as a dok_matrix\n\n        Raises:\n            QiskitOptimizationError: if coefficients are given in unsupported format.\n        \"\"\"\n        if (\n            isinstance(coefficients, list)\n            or isinstance(coefficients, ndarray)\n            and len(coefficients.shape) == 1\n        ):\n            coefficients = dok_matrix([coefficients])\n        elif isinstance(coefficients, spmatrix):\n            coefficients = dok_matrix(coefficients)\n        elif isinstance(coefficients, dict):\n            coeffs = dok_matrix((1, self.quadratic_program.get_num_vars()))\n            for index, value in coefficients.items():\n                if isinstance(index, str):\n                    index = self.quadratic_program.variables_index[index]\n                coeffs[0, index] = value\n            coefficients = coeffs\n        else:\n            raise QiskitOptimizationError(\"Unsupported format for coefficients.\")\n        return coefficients\n\n    @property\n    def coefficients(self) -&gt; dok_matrix:\n        \"\"\"Returns the coefficients of the linear expression.\n\n        Returns:\n            The coefficients of the linear expression.\n        \"\"\"\n        return self._coefficients\n\n    @coefficients.setter\n    def coefficients(\n        self,\n        coefficients: Union[\n            ndarray, spmatrix, List[float], Dict[Union[str, int], float]\n        ],\n    ) -&gt; None:\n        \"\"\"Sets the coefficients of the linear expression.\n\n        Args:\n            coefficients: The coefficients of the linear expression.\n        \"\"\"\n        self._coefficients = self._coeffs_to_dok_matrix(coefficients)\n\n    def to_array(self) -&gt; ndarray:\n        \"\"\"Returns the coefficients of the linear expression as array.\n\n        Returns:\n            An array with the coefficients corresponding to the linear expression.\n        \"\"\"\n        return self._coefficients.toarray()[0]\n\n    def to_dict(self, use_name: bool = False) -&gt; Dict[Union[int, str], float]:\n        \"\"\"Returns the coefficients of the linear expression as dictionary, either using variable\n        names or indices as keys.\n\n        Args:\n            use_name: Determines whether to use index or names to refer to variables.\n\n        Returns:\n            An dictionary with the coefficients corresponding to the linear expression.\n        \"\"\"\n        if use_name:\n            return {\n                self.quadratic_program.variables[k].name: v\n                for (_, k), v in self._coefficients.items()\n            }\n        else:\n            return {k: v for (_, k), v in self._coefficients.items()}\n\n    def evaluate(self, x: Union[ndarray, List, Dict[Union[int, str], float]]) -&gt; float:\n        \"\"\"Evaluate the linear expression for given variables.\n\n        Args:\n            x: The values of the variables to be evaluated.\n\n        Returns:\n            The value of the linear expression given the variable values.\n        \"\"\"\n        # cast input to dok_matrix if it is a dictionary\n        x = self._coeffs_to_dok_matrix(x)\n\n        # compute the dot-product of the input and the linear coefficients\n        val = (x @ self.coefficients.transpose())[0, 0]\n\n        # return the result\n        return val\n\n    # pylint: disable=unused-argument\n    def evaluate_gradient(\n        self, x: Union[ndarray, List, Dict[Union[int, str], float]]\n    ) -&gt; ndarray:\n        \"\"\"Evaluate the gradient of the linear expression for given variables.\n\n        Args:\n            x: The values of the variables to be evaluated.\n\n        Returns:\n            The value of the gradient of the linear expression given the variable values.\n        \"\"\"\n\n        # extract the coefficients as array and return it\n        return self.to_array()\n\n    @property\n    def bounds(self) -&gt; ExpressionBounds:\n        \"\"\"Returns the lower bound and the upper bound of the linear expression\n\n        Returns:\n            The lower bound and the upper bound of the linear expression\n\n        Raises:\n            QiskitOptimizationError: if the linear expression contains any unbounded variable\n\n        \"\"\"\n        l_b = u_b = 0.0\n        for ind, coeff in self.to_dict().items():\n            x = self.quadratic_program.get_variable(ind)\n            if x.lowerbound == -INFINITY or x.upperbound == INFINITY:\n                raise QiskitOptimizationError(\n                    f\"Linear expression contains an unbounded variable: {x.name}\"\n                )\n            lst = [coeff * x.lowerbound, coeff * x.upperbound]\n            l_b += min(lst)\n            u_b += max(lst)\n        return ExpressionBounds(lowerbound=l_b, upperbound=u_b)\n\n    def __repr__(self):\n        # pylint: disable=cyclic-import\n        from ..translators.prettyprint import expr2str, DEFAULT_TRUNCATE\n\n        return f\"&lt;{self.__class__.__name__}: {expr2str(linear=self, truncate=DEFAULT_TRUNCATE)}&gt;\"\n\n    def __str__(self):\n        # pylint: disable=cyclic-import\n        from ..translators.prettyprint import expr2str\n\n        return f\"{expr2str(linear=self)}\"\n</code></pre>"},{"location":"reference/q3as.quadratic/LinearExpression/#q3as.quadratic.LinearExpression.bounds","title":"<code>bounds: ExpressionBounds</code>  <code>property</code>","text":"<p>Returns the lower bound and the upper bound of the linear expression</p> <p>Returns:</p> Type Description <code>ExpressionBounds</code> <p>The lower bound and the upper bound of the linear expression</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if the linear expression contains any unbounded variable</p>"},{"location":"reference/q3as.quadratic/LinearExpression/#q3as.quadratic.LinearExpression.coefficients","title":"<code>coefficients: dok_matrix</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the coefficients of the linear expression.</p> <p>Returns:</p> Type Description <code>dok_matrix</code> <p>The coefficients of the linear expression.</p>"},{"location":"reference/q3as.quadratic/LinearExpression/#q3as.quadratic.LinearExpression.__getitem__","title":"<code>__getitem__(i)</code>","text":"<p>Returns the i-th coefficient where i can be a variable name or index.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>Union[int, str]</code> <p>the index or name of the variable corresponding to the coefficient.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The coefficient corresponding to the addressed variable.</p> Source code in <code>q3as/quadratic/problems/linear_expression.py</code> <pre><code>def __getitem__(self, i: Union[int, str]) -&gt; float:\n    \"\"\"Returns the i-th coefficient where i can be a variable name or index.\n\n    Args:\n        i: the index or name of the variable corresponding to the coefficient.\n\n    Returns:\n        The coefficient corresponding to the addressed variable.\n    \"\"\"\n    if isinstance(i, str):\n        i = self.quadratic_program.variables_index[i]\n    return self.coefficients[0, i]\n</code></pre>"},{"location":"reference/q3as.quadratic/LinearExpression/#q3as.quadratic.LinearExpression.__init__","title":"<code>__init__(quadratic_program, coefficients)</code>","text":"<p>Creates a new linear expression.</p> <p>The linear expression can be defined via an array, a list, a sparse matrix, or a dictionary that uses variable names or indices as keys and stores the values internally as a dok_matrix.</p> <p>Parameters:</p> Name Type Description Default <code>quadratic_program</code> <code>Any</code> <p>The parent QuadraticProgram.</p> required <code>coefficients</code> <code>Union[ndarray, spmatrix, List[float], Dict[Union[int, str], float]]</code> <p>The (sparse) representation of the coefficients.</p> required Source code in <code>q3as/quadratic/problems/linear_expression.py</code> <pre><code>def __init__(\n    self,\n    quadratic_program: Any,\n    coefficients: Union[\n        ndarray, spmatrix, List[float], Dict[Union[int, str], float]\n    ],\n) -&gt; None:\n    \"\"\"Creates a new linear expression.\n\n    The linear expression can be defined via an array, a list, a sparse matrix, or a dictionary\n    that uses variable names or indices as keys and stores the values internally as a\n    dok_matrix.\n\n    Args:\n        quadratic_program: The parent QuadraticProgram.\n        coefficients: The (sparse) representation of the coefficients.\n\n    \"\"\"\n    super().__init__(quadratic_program)\n    self.coefficients = coefficients\n</code></pre>"},{"location":"reference/q3as.quadratic/LinearExpression/#q3as.quadratic.LinearExpression.evaluate","title":"<code>evaluate(x)</code>","text":"<p>Evaluate the linear expression for given variables.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ndarray, List, Dict[Union[int, str], float]]</code> <p>The values of the variables to be evaluated.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value of the linear expression given the variable values.</p> Source code in <code>q3as/quadratic/problems/linear_expression.py</code> <pre><code>def evaluate(self, x: Union[ndarray, List, Dict[Union[int, str], float]]) -&gt; float:\n    \"\"\"Evaluate the linear expression for given variables.\n\n    Args:\n        x: The values of the variables to be evaluated.\n\n    Returns:\n        The value of the linear expression given the variable values.\n    \"\"\"\n    # cast input to dok_matrix if it is a dictionary\n    x = self._coeffs_to_dok_matrix(x)\n\n    # compute the dot-product of the input and the linear coefficients\n    val = (x @ self.coefficients.transpose())[0, 0]\n\n    # return the result\n    return val\n</code></pre>"},{"location":"reference/q3as.quadratic/LinearExpression/#q3as.quadratic.LinearExpression.evaluate_gradient","title":"<code>evaluate_gradient(x)</code>","text":"<p>Evaluate the gradient of the linear expression for given variables.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ndarray, List, Dict[Union[int, str], float]]</code> <p>The values of the variables to be evaluated.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The value of the gradient of the linear expression given the variable values.</p> Source code in <code>q3as/quadratic/problems/linear_expression.py</code> <pre><code>def evaluate_gradient(\n    self, x: Union[ndarray, List, Dict[Union[int, str], float]]\n) -&gt; ndarray:\n    \"\"\"Evaluate the gradient of the linear expression for given variables.\n\n    Args:\n        x: The values of the variables to be evaluated.\n\n    Returns:\n        The value of the gradient of the linear expression given the variable values.\n    \"\"\"\n\n    # extract the coefficients as array and return it\n    return self.to_array()\n</code></pre>"},{"location":"reference/q3as.quadratic/LinearExpression/#q3as.quadratic.LinearExpression.to_array","title":"<code>to_array()</code>","text":"<p>Returns the coefficients of the linear expression as array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array with the coefficients corresponding to the linear expression.</p> Source code in <code>q3as/quadratic/problems/linear_expression.py</code> <pre><code>def to_array(self) -&gt; ndarray:\n    \"\"\"Returns the coefficients of the linear expression as array.\n\n    Returns:\n        An array with the coefficients corresponding to the linear expression.\n    \"\"\"\n    return self._coefficients.toarray()[0]\n</code></pre>"},{"location":"reference/q3as.quadratic/LinearExpression/#q3as.quadratic.LinearExpression.to_dict","title":"<code>to_dict(use_name=False)</code>","text":"<p>Returns the coefficients of the linear expression as dictionary, either using variable names or indices as keys.</p> <p>Parameters:</p> Name Type Description Default <code>use_name</code> <code>bool</code> <p>Determines whether to use index or names to refer to variables.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[Union[int, str], float]</code> <p>An dictionary with the coefficients corresponding to the linear expression.</p> Source code in <code>q3as/quadratic/problems/linear_expression.py</code> <pre><code>def to_dict(self, use_name: bool = False) -&gt; Dict[Union[int, str], float]:\n    \"\"\"Returns the coefficients of the linear expression as dictionary, either using variable\n    names or indices as keys.\n\n    Args:\n        use_name: Determines whether to use index or names to refer to variables.\n\n    Returns:\n        An dictionary with the coefficients corresponding to the linear expression.\n    \"\"\"\n    if use_name:\n        return {\n            self.quadratic_program.variables[k].name: v\n            for (_, k), v in self._coefficients.items()\n        }\n    else:\n        return {k: v for (_, k), v in self._coefficients.items()}\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticConstraint/","title":"QuadraticConstraint","text":"<p>               Bases: <code>Constraint</code></p> <p>Representation of a quadratic constraint.</p> Source code in <code>q3as/quadratic/problems/quadratic_constraint.py</code> <pre><code>class QuadraticConstraint(Constraint):\n    \"\"\"Representation of a quadratic constraint.\"\"\"\n\n    # Note: added, duplicating in effect that in Constraint, to avoid issues with Sphinx\n    Sense = ConstraintSense\n\n    def __init__(\n        self,\n        quadratic_program: Any,\n        name: str,\n        linear: Union[ndarray, spmatrix, List[float], Dict[Union[str, int], float]],\n        quadratic: Union[\n            ndarray,\n            spmatrix,\n            List[List[float]],\n            Dict[Tuple[Union[int, str], Union[int, str]], float],\n        ],\n        sense: ConstraintSense,\n        rhs: float,\n    ) -&gt; None:\n        \"\"\"Constructs a quadratic constraint, consisting of a linear and a quadratic term.\n\n        Args:\n            quadratic_program: The parent quadratic program.\n            name: The name of the constraint.\n            linear: The coefficients specifying the linear part of the constraint.\n            quadratic: The coefficients specifying the linear part of the constraint.\n            sense: The sense of the constraint.\n            rhs: The right-hand-side of the constraint.\n        \"\"\"\n        super().__init__(quadratic_program, name, sense, rhs)\n        self._linear = LinearExpression(quadratic_program, linear)\n        self._quadratic = QuadraticExpression(quadratic_program, quadratic)\n\n    @property\n    def linear(self) -&gt; LinearExpression:\n        \"\"\"Returns the linear expression corresponding to the left-hand-side of the constraint.\n\n        Returns:\n            The left-hand-side linear expression.\n        \"\"\"\n        return self._linear\n\n    @linear.setter\n    def linear(\n        self,\n        linear: Union[ndarray, spmatrix, List[float], Dict[Union[str, int], float]],\n    ) -&gt; None:\n        \"\"\"Sets the linear expression corresponding to the left-hand-side of the constraint.\n        The coefficients can either be given by an array, a (sparse) 1d matrix, a list or a\n        dictionary.\n\n        Args:\n            linear: The linear coefficients of the left-hand-side.\n        \"\"\"\n\n        self._linear = LinearExpression(self.quadratic_program, linear)\n\n    @property\n    def quadratic(self) -&gt; QuadraticExpression:\n        \"\"\"Returns the quadratic expression corresponding to the left-hand-side of the constraint.\n\n        Returns:\n            The left-hand-side quadratic expression.\n        \"\"\"\n        return self._quadratic\n\n    @quadratic.setter\n    def quadratic(\n        self,\n        quadratic: Union[\n            ndarray,\n            spmatrix,\n            List[List[float]],\n            Dict[Tuple[Union[int, str], Union[int, str]], float],\n        ],\n    ) -&gt; None:\n        \"\"\"Sets the quadratic expression corresponding to the left-hand-side of the constraint.\n        The coefficients can either be given by an array, a (sparse) matrix, a list or a\n        dictionary.\n\n        Args:\n            quadratic: The quadratic coefficients of the left-hand-side.\n        \"\"\"\n        self._quadratic = QuadraticExpression(self.quadratic_program, quadratic)\n\n    def evaluate(self, x: Union[ndarray, List, Dict[Union[int, str], float]]) -&gt; float:\n        \"\"\"Evaluate the left-hand-side of the constraint.\n\n        Args:\n            x: The values of the variables to be evaluated.\n\n        Returns:\n            The left-hand-side of the constraint given the variable values.\n        \"\"\"\n        return self.linear.evaluate(x) + self.quadratic.evaluate(x)\n\n    def __repr__(self):\n        # pylint: disable=cyclic-import\n        from ..translators.prettyprint import expr2str, DEFAULT_TRUNCATE\n\n        lhs = expr2str(\n            linear=self.linear, quadratic=self.quadratic, truncate=DEFAULT_TRUNCATE\n        )\n        return f\"&lt;{self.__class__.__name__}: {lhs} {self.sense.label} {self.rhs} '{self.name}'&gt;\"\n\n    def __str__(self):\n        # pylint: disable=cyclic-import\n        from ..translators.prettyprint import expr2str\n\n        lhs = expr2str(linear=self.linear, quadratic=self.quadratic)\n        return f\"{lhs} {self.sense.label} {self.rhs} '{self.name}'\"\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticConstraint/#q3as.quadratic.QuadraticConstraint.linear","title":"<code>linear: LinearExpression</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the linear expression corresponding to the left-hand-side of the constraint.</p> <p>Returns:</p> Type Description <code>LinearExpression</code> <p>The left-hand-side linear expression.</p>"},{"location":"reference/q3as.quadratic/QuadraticConstraint/#q3as.quadratic.QuadraticConstraint.quadratic","title":"<code>quadratic: QuadraticExpression</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the quadratic expression corresponding to the left-hand-side of the constraint.</p> <p>Returns:</p> Type Description <code>QuadraticExpression</code> <p>The left-hand-side quadratic expression.</p>"},{"location":"reference/q3as.quadratic/QuadraticConstraint/#q3as.quadratic.QuadraticConstraint.__init__","title":"<code>__init__(quadratic_program, name, linear, quadratic, sense, rhs)</code>","text":"<p>Constructs a quadratic constraint, consisting of a linear and a quadratic term.</p> <p>Parameters:</p> Name Type Description Default <code>quadratic_program</code> <code>Any</code> <p>The parent quadratic program.</p> required <code>name</code> <code>str</code> <p>The name of the constraint.</p> required <code>linear</code> <code>Union[ndarray, spmatrix, List[float], Dict[Union[str, int], float]]</code> <p>The coefficients specifying the linear part of the constraint.</p> required <code>quadratic</code> <code>Union[ndarray, spmatrix, List[List[float]], Dict[Tuple[Union[int, str], Union[int, str]], float]]</code> <p>The coefficients specifying the linear part of the constraint.</p> required <code>sense</code> <code>ConstraintSense</code> <p>The sense of the constraint.</p> required <code>rhs</code> <code>float</code> <p>The right-hand-side of the constraint.</p> required Source code in <code>q3as/quadratic/problems/quadratic_constraint.py</code> <pre><code>def __init__(\n    self,\n    quadratic_program: Any,\n    name: str,\n    linear: Union[ndarray, spmatrix, List[float], Dict[Union[str, int], float]],\n    quadratic: Union[\n        ndarray,\n        spmatrix,\n        List[List[float]],\n        Dict[Tuple[Union[int, str], Union[int, str]], float],\n    ],\n    sense: ConstraintSense,\n    rhs: float,\n) -&gt; None:\n    \"\"\"Constructs a quadratic constraint, consisting of a linear and a quadratic term.\n\n    Args:\n        quadratic_program: The parent quadratic program.\n        name: The name of the constraint.\n        linear: The coefficients specifying the linear part of the constraint.\n        quadratic: The coefficients specifying the linear part of the constraint.\n        sense: The sense of the constraint.\n        rhs: The right-hand-side of the constraint.\n    \"\"\"\n    super().__init__(quadratic_program, name, sense, rhs)\n    self._linear = LinearExpression(quadratic_program, linear)\n    self._quadratic = QuadraticExpression(quadratic_program, quadratic)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticConstraint/#q3as.quadratic.QuadraticConstraint.evaluate","title":"<code>evaluate(x)</code>","text":"<p>Evaluate the left-hand-side of the constraint.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ndarray, List, Dict[Union[int, str], float]]</code> <p>The values of the variables to be evaluated.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The left-hand-side of the constraint given the variable values.</p> Source code in <code>q3as/quadratic/problems/quadratic_constraint.py</code> <pre><code>def evaluate(self, x: Union[ndarray, List, Dict[Union[int, str], float]]) -&gt; float:\n    \"\"\"Evaluate the left-hand-side of the constraint.\n\n    Args:\n        x: The values of the variables to be evaluated.\n\n    Returns:\n        The left-hand-side of the constraint given the variable values.\n    \"\"\"\n    return self.linear.evaluate(x) + self.quadratic.evaluate(x)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticExpression/","title":"QuadraticExpression","text":"<p>               Bases: <code>QuadraticProgramElement</code></p> <p>Representation of a quadratic expression by its coefficients.</p> Source code in <code>q3as/quadratic/problems/quadratic_expression.py</code> <pre><code>class QuadraticExpression(QuadraticProgramElement):\n    \"\"\"Representation of a quadratic expression by its coefficients.\"\"\"\n\n    def __init__(\n        self,\n        quadratic_program: Any,\n        coefficients: Union[\n            ndarray,\n            spmatrix,\n            List[List[float]],\n            Dict[Tuple[Union[int, str], Union[int, str]], float],\n        ],\n    ) -&gt; None:\n        \"\"\"Creates a new quadratic expression.\n\n        The quadratic expression can be defined via an array, a list, a sparse matrix, or a\n        dictionary that uses variable names or indices as keys and stores the values internally as a\n        dok_matrix. We stores values in a compressed way, i.e., values at symmetric positions are\n        summed up in the upper triangle. For example, {(0, 1): 1, (1, 0): 2} -&gt; {(0, 1): 3}.\n\n        Args:\n            quadratic_program: The parent QuadraticProgram.\n            coefficients: The (sparse) representation of the coefficients.\n\n        \"\"\"\n        super().__init__(quadratic_program)\n        self.coefficients = coefficients\n\n    def __getitem__(self, key: Tuple[Union[int, str], Union[int, str]]) -&gt; float:\n        \"\"\"Returns the coefficient where i, j can be a variable names or indices.\n\n        Args:\n            key: The tuple of indices or names of the variables corresponding to the coefficient.\n\n        Returns:\n            The coefficient corresponding to the addressed variables.\n        \"\"\"\n        i, j = key\n        if isinstance(i, str):\n            i = self.quadratic_program.variables_index[i]\n        if isinstance(j, str):\n            j = self.quadratic_program.variables_index[j]\n        return self.coefficients[min(i, j), max(i, j)]\n\n    def __setitem__(\n        self, key: Tuple[Union[int, str], Union[int, str]], value: float\n    ) -&gt; None:\n        \"\"\"Sets the coefficient where i, j can be a variable names or indices.\n\n        Args:\n            key: The tuple of indices or names of the variables corresponding to the coefficient.\n            value: The coefficient corresponding to the addressed variables.\n        \"\"\"\n        i, j = key\n        if isinstance(i, str):\n            i = self.quadratic_program.variables_index[i]\n        if isinstance(j, str):\n            j = self.quadratic_program.variables_index[j]\n        self.coefficients[min(i, j), max(i, j)] = value\n\n    def _coeffs_to_dok_matrix(\n        self,\n        coefficients: Union[\n            ndarray,\n            spmatrix,\n            List[List[float]],\n            Dict[Tuple[Union[int, str], Union[int, str]], float],\n        ],\n    ) -&gt; dok_matrix:\n        \"\"\"Maps given coefficients to a dok_matrix.\n\n        Args:\n            coefficients: The coefficients to be mapped.\n\n        Returns:\n            The given coefficients as a dok_matrix\n\n        Raises:\n            QiskitOptimizationError: if coefficients are given in unsupported format.\n        \"\"\"\n        if isinstance(coefficients, (list, ndarray, spmatrix)):\n            coefficients = dok_matrix(coefficients)\n        elif isinstance(coefficients, dict):\n            n = self.quadratic_program.get_num_vars()\n            coeffs = dok_matrix((n, n))\n            for (i, j), value in coefficients.items():\n                if isinstance(i, str):\n                    i = self.quadratic_program.variables_index[i]\n                if isinstance(j, str):\n                    j = self.quadratic_program.variables_index[j]\n                coeffs[i, j] = value\n            coefficients = coeffs\n        else:\n            raise QiskitOptimizationError(\n                f\"Unsupported format for coefficients: {coefficients}\"\n            )\n        return self._triangle_matrix(coefficients)\n\n    @staticmethod\n    def _triangle_matrix(mat: dok_matrix) -&gt; dok_matrix:\n        lower = tril(mat, -1, format=\"dok\")\n        # `todok` is necessary because subtraction results in other format\n        return (mat + lower.transpose() - lower).todok()\n\n    @staticmethod\n    def _symmetric_matrix(mat: dok_matrix) -&gt; dok_matrix:\n        upper = triu(mat, 1, format=\"dok\") / 2\n        # `todok` is necessary because subtraction results in other format\n        return (mat + upper.transpose() - upper).todok()\n\n    @property\n    def coefficients(self) -&gt; dok_matrix:\n        \"\"\"Returns the coefficients of the quadratic expression.\n\n        Returns:\n            The coefficients of the quadratic expression.\n        \"\"\"\n        return self._coefficients\n\n    @coefficients.setter\n    def coefficients(\n        self,\n        coefficients: Union[\n            ndarray,\n            spmatrix,\n            List[List[float]],\n            Dict[Tuple[Union[int, str], Union[int, str]], float],\n        ],\n    ) -&gt; None:\n        \"\"\"Sets the coefficients of the quadratic expression.\n\n        Args:\n            coefficients: The coefficients of the quadratic expression.\n        \"\"\"\n        self._coefficients = self._coeffs_to_dok_matrix(coefficients)\n\n    def to_array(self, symmetric: bool = False) -&gt; ndarray:\n        \"\"\"Returns the coefficients of the quadratic expression as array.\n\n        Args:\n            symmetric: Determines whether the output is in a symmetric form or not.\n\n        Returns:\n            An array with the coefficients corresponding to the quadratic expression.\n        \"\"\"\n        coeffs = (\n            self._symmetric_matrix(self._coefficients)\n            if symmetric\n            else self._coefficients\n        )\n        return coeffs.toarray()\n\n    def to_dict(\n        self, symmetric: bool = False, use_name: bool = False\n    ) -&gt; Dict[Union[Tuple[int, int], Tuple[str, str]], float]:\n        \"\"\"Returns the coefficients of the quadratic expression as dictionary, either using tuples\n        of variable names or indices as keys.\n\n        Args:\n            symmetric: Determines whether the output is in a symmetric form or not.\n            use_name: Determines whether to use index or names to refer to variables.\n\n        Returns:\n            An dictionary with the coefficients corresponding to the quadratic expression.\n        \"\"\"\n        coeffs = (\n            self._symmetric_matrix(self._coefficients)\n            if symmetric\n            else self._coefficients\n        )\n        if use_name:\n            return {\n                (\n                    self.quadratic_program.variables[i].name,\n                    self.quadratic_program.variables[j].name,\n                ): v\n                for (i, j), v in coeffs.items()\n            }\n        else:\n            return {(int(i), int(j)): v for (i, j), v in coeffs.items()}\n\n    def evaluate(self, x: Union[ndarray, List, Dict[Union[int, str], float]]) -&gt; float:\n        \"\"\"Evaluate the quadratic expression for given variables: x * Q * x.\n\n        Args:\n            x: The values of the variables to be evaluated.\n\n        Returns:\n            The value of the quadratic expression given the variable values.\n        \"\"\"\n        x = self._cast_as_array(x)\n\n        # compute x * Q * x for the quadratic expression\n        val = x @ self.coefficients @ x\n\n        # return the result\n        return val\n\n    def evaluate_gradient(\n        self, x: Union[ndarray, List, Dict[Union[int, str], float]]\n    ) -&gt; ndarray:\n        \"\"\"Evaluate the gradient of the quadratic expression for given variables.\n\n        Args:\n            x: The values of the variables to be evaluated.\n\n        Returns:\n            The value of the gradient quadratic expression given the variable values.\n        \"\"\"\n        x = self._cast_as_array(x)\n\n        # compute (Q' + Q) * x for the quadratic expression\n        val = (self.coefficients.transpose() + self.coefficients) @ x\n\n        # return the result\n        return val\n\n    def _cast_as_array(\n        self, x: Union[ndarray, List, Dict[Union[int, str], float]]\n    ) -&gt; Union[dok_matrix, np.ndarray]:\n        \"\"\"Converts input to an array if it is a dictionary or list.\"\"\"\n        if isinstance(x, dict):\n            x_aux = np.zeros(self.quadratic_program.get_num_vars())\n            for i, v in x.items():\n                if isinstance(i, str):\n                    i = self.quadratic_program.variables_index[i]\n                x_aux[i] = v\n            x = x_aux\n        if isinstance(x, list):\n            x = np.array(x)\n        return x\n\n    @property\n    def bounds(self) -&gt; ExpressionBounds:\n        \"\"\"Returns the lower bound and the upper bound of the quadratic expression\n\n        Returns:\n            The lower bound and the upper bound of the quadratic expression\n\n        Raises:\n            QiskitOptimizationError: if the quadratic expression contains any unbounded variable\n        \"\"\"\n        l_b = u_b = 0.0\n        for (ind1, ind2), coeff in self.to_dict().items():\n            x = self.quadratic_program.get_variable(ind1)\n            if x.lowerbound == -INFINITY or x.upperbound == INFINITY:\n                raise QiskitOptimizationError(\n                    f\"Quadratic expression contains an unbounded variable: {x.name}\"\n                )\n            y = self.quadratic_program.get_variable(ind2)\n            if y.lowerbound == -INFINITY or y.upperbound == INFINITY:\n                raise QiskitOptimizationError(\n                    f\"Quadratic expression contains an unbounded variable: {y.name}\"\n                )\n            lst = []\n            if ind1 == ind2:\n                if x.lowerbound * x.upperbound &lt;= 0.0:\n                    # lower bound and upper bound have different signs\n                    lst.append(0.0)\n                lst.extend([x.lowerbound**2, x.upperbound**2])\n            else:\n                lst.extend(\n                    [\n                        x.lowerbound * y.lowerbound,\n                        x.lowerbound * y.upperbound,\n                        x.upperbound * y.lowerbound,\n                        x.upperbound * y.upperbound,\n                    ]\n                )\n            lst2 = [coeff * val for val in lst]\n            l_b += min(lst2)\n            u_b += max(lst2)\n        return ExpressionBounds(lowerbound=l_b, upperbound=u_b)\n\n    def __repr__(self):\n        # pylint: disable=cyclic-import\n        from ..translators.prettyprint import expr2str, DEFAULT_TRUNCATE\n\n        return f\"&lt;{self.__class__.__name__}: {expr2str(quadratic=self, truncate=DEFAULT_TRUNCATE)}&gt;\"\n\n    def __str__(self):\n        # pylint: disable=cyclic-import\n        from ..translators.prettyprint import expr2str\n\n        return f\"{expr2str(quadratic=self)}\"\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticExpression/#q3as.quadratic.QuadraticExpression.bounds","title":"<code>bounds: ExpressionBounds</code>  <code>property</code>","text":"<p>Returns the lower bound and the upper bound of the quadratic expression</p> <p>Returns:</p> Type Description <code>ExpressionBounds</code> <p>The lower bound and the upper bound of the quadratic expression</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if the quadratic expression contains any unbounded variable</p>"},{"location":"reference/q3as.quadratic/QuadraticExpression/#q3as.quadratic.QuadraticExpression.coefficients","title":"<code>coefficients: dok_matrix</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the coefficients of the quadratic expression.</p> <p>Returns:</p> Type Description <code>dok_matrix</code> <p>The coefficients of the quadratic expression.</p>"},{"location":"reference/q3as.quadratic/QuadraticExpression/#q3as.quadratic.QuadraticExpression.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Returns the coefficient where i, j can be a variable names or indices.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Tuple[Union[int, str], Union[int, str]]</code> <p>The tuple of indices or names of the variables corresponding to the coefficient.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The coefficient corresponding to the addressed variables.</p> Source code in <code>q3as/quadratic/problems/quadratic_expression.py</code> <pre><code>def __getitem__(self, key: Tuple[Union[int, str], Union[int, str]]) -&gt; float:\n    \"\"\"Returns the coefficient where i, j can be a variable names or indices.\n\n    Args:\n        key: The tuple of indices or names of the variables corresponding to the coefficient.\n\n    Returns:\n        The coefficient corresponding to the addressed variables.\n    \"\"\"\n    i, j = key\n    if isinstance(i, str):\n        i = self.quadratic_program.variables_index[i]\n    if isinstance(j, str):\n        j = self.quadratic_program.variables_index[j]\n    return self.coefficients[min(i, j), max(i, j)]\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticExpression/#q3as.quadratic.QuadraticExpression.__init__","title":"<code>__init__(quadratic_program, coefficients)</code>","text":"<p>Creates a new quadratic expression.</p> <p>The quadratic expression can be defined via an array, a list, a sparse matrix, or a dictionary that uses variable names or indices as keys and stores the values internally as a dok_matrix. We stores values in a compressed way, i.e., values at symmetric positions are summed up in the upper triangle. For example, {(0, 1): 1, (1, 0): 2} -&gt; {(0, 1): 3}.</p> <p>Parameters:</p> Name Type Description Default <code>quadratic_program</code> <code>Any</code> <p>The parent QuadraticProgram.</p> required <code>coefficients</code> <code>Union[ndarray, spmatrix, List[List[float]], Dict[Tuple[Union[int, str], Union[int, str]], float]]</code> <p>The (sparse) representation of the coefficients.</p> required Source code in <code>q3as/quadratic/problems/quadratic_expression.py</code> <pre><code>def __init__(\n    self,\n    quadratic_program: Any,\n    coefficients: Union[\n        ndarray,\n        spmatrix,\n        List[List[float]],\n        Dict[Tuple[Union[int, str], Union[int, str]], float],\n    ],\n) -&gt; None:\n    \"\"\"Creates a new quadratic expression.\n\n    The quadratic expression can be defined via an array, a list, a sparse matrix, or a\n    dictionary that uses variable names or indices as keys and stores the values internally as a\n    dok_matrix. We stores values in a compressed way, i.e., values at symmetric positions are\n    summed up in the upper triangle. For example, {(0, 1): 1, (1, 0): 2} -&gt; {(0, 1): 3}.\n\n    Args:\n        quadratic_program: The parent QuadraticProgram.\n        coefficients: The (sparse) representation of the coefficients.\n\n    \"\"\"\n    super().__init__(quadratic_program)\n    self.coefficients = coefficients\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticExpression/#q3as.quadratic.QuadraticExpression.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Sets the coefficient where i, j can be a variable names or indices.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Tuple[Union[int, str], Union[int, str]]</code> <p>The tuple of indices or names of the variables corresponding to the coefficient.</p> required <code>value</code> <code>float</code> <p>The coefficient corresponding to the addressed variables.</p> required Source code in <code>q3as/quadratic/problems/quadratic_expression.py</code> <pre><code>def __setitem__(\n    self, key: Tuple[Union[int, str], Union[int, str]], value: float\n) -&gt; None:\n    \"\"\"Sets the coefficient where i, j can be a variable names or indices.\n\n    Args:\n        key: The tuple of indices or names of the variables corresponding to the coefficient.\n        value: The coefficient corresponding to the addressed variables.\n    \"\"\"\n    i, j = key\n    if isinstance(i, str):\n        i = self.quadratic_program.variables_index[i]\n    if isinstance(j, str):\n        j = self.quadratic_program.variables_index[j]\n    self.coefficients[min(i, j), max(i, j)] = value\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticExpression/#q3as.quadratic.QuadraticExpression.evaluate","title":"<code>evaluate(x)</code>","text":"<p>Evaluate the quadratic expression for given variables: x * Q * x.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ndarray, List, Dict[Union[int, str], float]]</code> <p>The values of the variables to be evaluated.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value of the quadratic expression given the variable values.</p> Source code in <code>q3as/quadratic/problems/quadratic_expression.py</code> <pre><code>def evaluate(self, x: Union[ndarray, List, Dict[Union[int, str], float]]) -&gt; float:\n    \"\"\"Evaluate the quadratic expression for given variables: x * Q * x.\n\n    Args:\n        x: The values of the variables to be evaluated.\n\n    Returns:\n        The value of the quadratic expression given the variable values.\n    \"\"\"\n    x = self._cast_as_array(x)\n\n    # compute x * Q * x for the quadratic expression\n    val = x @ self.coefficients @ x\n\n    # return the result\n    return val\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticExpression/#q3as.quadratic.QuadraticExpression.evaluate_gradient","title":"<code>evaluate_gradient(x)</code>","text":"<p>Evaluate the gradient of the quadratic expression for given variables.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ndarray, List, Dict[Union[int, str], float]]</code> <p>The values of the variables to be evaluated.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The value of the gradient quadratic expression given the variable values.</p> Source code in <code>q3as/quadratic/problems/quadratic_expression.py</code> <pre><code>def evaluate_gradient(\n    self, x: Union[ndarray, List, Dict[Union[int, str], float]]\n) -&gt; ndarray:\n    \"\"\"Evaluate the gradient of the quadratic expression for given variables.\n\n    Args:\n        x: The values of the variables to be evaluated.\n\n    Returns:\n        The value of the gradient quadratic expression given the variable values.\n    \"\"\"\n    x = self._cast_as_array(x)\n\n    # compute (Q' + Q) * x for the quadratic expression\n    val = (self.coefficients.transpose() + self.coefficients) @ x\n\n    # return the result\n    return val\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticExpression/#q3as.quadratic.QuadraticExpression.to_array","title":"<code>to_array(symmetric=False)</code>","text":"<p>Returns the coefficients of the quadratic expression as array.</p> <p>Parameters:</p> Name Type Description Default <code>symmetric</code> <code>bool</code> <p>Determines whether the output is in a symmetric form or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array with the coefficients corresponding to the quadratic expression.</p> Source code in <code>q3as/quadratic/problems/quadratic_expression.py</code> <pre><code>def to_array(self, symmetric: bool = False) -&gt; ndarray:\n    \"\"\"Returns the coefficients of the quadratic expression as array.\n\n    Args:\n        symmetric: Determines whether the output is in a symmetric form or not.\n\n    Returns:\n        An array with the coefficients corresponding to the quadratic expression.\n    \"\"\"\n    coeffs = (\n        self._symmetric_matrix(self._coefficients)\n        if symmetric\n        else self._coefficients\n    )\n    return coeffs.toarray()\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticExpression/#q3as.quadratic.QuadraticExpression.to_dict","title":"<code>to_dict(symmetric=False, use_name=False)</code>","text":"<p>Returns the coefficients of the quadratic expression as dictionary, either using tuples of variable names or indices as keys.</p> <p>Parameters:</p> Name Type Description Default <code>symmetric</code> <code>bool</code> <p>Determines whether the output is in a symmetric form or not.</p> <code>False</code> <code>use_name</code> <code>bool</code> <p>Determines whether to use index or names to refer to variables.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[Union[Tuple[int, int], Tuple[str, str]], float]</code> <p>An dictionary with the coefficients corresponding to the quadratic expression.</p> Source code in <code>q3as/quadratic/problems/quadratic_expression.py</code> <pre><code>def to_dict(\n    self, symmetric: bool = False, use_name: bool = False\n) -&gt; Dict[Union[Tuple[int, int], Tuple[str, str]], float]:\n    \"\"\"Returns the coefficients of the quadratic expression as dictionary, either using tuples\n    of variable names or indices as keys.\n\n    Args:\n        symmetric: Determines whether the output is in a symmetric form or not.\n        use_name: Determines whether to use index or names to refer to variables.\n\n    Returns:\n        An dictionary with the coefficients corresponding to the quadratic expression.\n    \"\"\"\n    coeffs = (\n        self._symmetric_matrix(self._coefficients)\n        if symmetric\n        else self._coefficients\n    )\n    if use_name:\n        return {\n            (\n                self.quadratic_program.variables[i].name,\n                self.quadratic_program.variables[j].name,\n            ): v\n            for (i, j), v in coeffs.items()\n        }\n    else:\n        return {(int(i), int(j)): v for (i, j), v in coeffs.items()}\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticObjective/","title":"QuadraticObjective","text":"<p>               Bases: <code>QuadraticProgramElement</code></p> <p>Representation of quadratic objective function of the form: constant + linear * x + x * quadratic * x.</p> Source code in <code>q3as/quadratic/problems/quadratic_objective.py</code> <pre><code>class QuadraticObjective(QuadraticProgramElement):\n    \"\"\"Representation of quadratic objective function of the form:\n    constant + linear * x + x * quadratic * x.\n    \"\"\"\n\n    Sense = ObjSense\n\n    def __init__(\n        self,\n        quadratic_program: Any,\n        constant: float = 0.0,\n        linear: Optional[\n            Union[ndarray, spmatrix, List[float], Dict[Union[str, int], float]]\n        ] = None,\n        quadratic: Optional[\n            Union[\n                ndarray,\n                spmatrix,\n                List[List[float]],\n                Dict[Tuple[Union[int, str], Union[int, str]], float],\n            ]\n        ] = None,\n        sense: ObjSense = ObjSense.MINIMIZE,\n    ) -&gt; None:\n        \"\"\"Constructs a quadratic objective function.\n\n        Args:\n            quadratic_program: The parent quadratic program.\n            constant: The constant offset of the objective.\n            linear: The coefficients of the linear part of the objective.\n            quadratic: The coefficients of the quadratic part of the objective.\n            sense: The optimization sense of the objective.\n        \"\"\"\n        super().__init__(quadratic_program)\n        self._constant = constant\n        if linear is None:\n            linear = {}\n        self._linear = LinearExpression(quadratic_program, linear)\n        if quadratic is None:\n            quadratic = {}\n        self._quadratic = QuadraticExpression(quadratic_program, quadratic)\n        self._sense = sense\n\n    @property\n    def constant(self) -&gt; float:\n        \"\"\"Returns the constant part of the objective function.\n\n        Returns:\n            The constant part of the objective function.\n        \"\"\"\n        return self._constant\n\n    @constant.setter\n    def constant(self, constant: float) -&gt; None:\n        \"\"\"Sets the constant part of the objective function.\n\n        Args:\n            constant: The constant part of the objective function.\n        \"\"\"\n        self._constant = constant\n\n    @property\n    def linear(self) -&gt; LinearExpression:\n        \"\"\"Returns the linear part of the objective function.\n\n        Returns:\n            The linear part of the objective function.\n        \"\"\"\n        return self._linear\n\n    @linear.setter\n    def linear(\n        self,\n        linear: Union[ndarray, spmatrix, List[float], Dict[Union[str, int], float]],\n    ) -&gt; None:\n        \"\"\"Sets the coefficients of the linear part of the objective function.\n\n        Args:\n            linear: The coefficients of the linear part of the objective function.\n\n        \"\"\"\n        self._linear = LinearExpression(self.quadratic_program, linear)\n\n    @property\n    def quadratic(self) -&gt; QuadraticExpression:\n        \"\"\"Returns the quadratic part of the objective function.\n\n        Returns:\n            The quadratic part of the objective function.\n        \"\"\"\n        return self._quadratic\n\n    @quadratic.setter\n    def quadratic(\n        self,\n        quadratic: Union[\n            ndarray,\n            spmatrix,\n            List[List[float]],\n            Dict[Tuple[Union[int, str], Union[int, str]], float],\n        ],\n    ) -&gt; None:\n        \"\"\"Sets the coefficients of the quadratic part of the objective function.\n\n        Args:\n            quadratic: The coefficients of the quadratic part of the objective function.\n\n        \"\"\"\n        self._quadratic = QuadraticExpression(self.quadratic_program, quadratic)\n\n    @property\n    def sense(self) -&gt; ObjSense:\n        \"\"\"Returns the sense of the objective function.\n\n        Returns:\n            The sense of the objective function.\n        \"\"\"\n        return self._sense\n\n    @sense.setter\n    def sense(self, sense: ObjSense) -&gt; None:\n        \"\"\"Sets the sense of the objective function.\n\n        Args:\n            sense: The sense of the objective function.\n        \"\"\"\n        self._sense = sense\n\n    def evaluate(self, x: Union[ndarray, List, Dict[Union[int, str], float]]) -&gt; float:\n        \"\"\"Evaluate the quadratic objective for given variable values.\n\n        Args:\n            x: The values of the variables to be evaluated.\n\n        Returns:\n            The value of the quadratic objective given the variable values.\n\n        Raises:\n            QiskitOptimizationError: if the shape of the objective function does not match with\n                the number of variables.\n        \"\"\"\n        n = self.quadratic_program.get_num_vars()\n        if self.linear.coefficients.shape != (\n            1,\n            n,\n        ) or self.quadratic.coefficients.shape != (n, n):\n            raise QiskitOptimizationError(\n                \"The shape of the objective function does not match with the number of variables. \"\n                \"Need to define the objective function after defining all variables\"\n            )\n        return self.constant + self.linear.evaluate(x) + self.quadratic.evaluate(x)\n\n    def evaluate_gradient(\n        self, x: Union[ndarray, List, Dict[Union[int, str], float]]\n    ) -&gt; ndarray:\n        \"\"\"Evaluate the gradient of the quadratic objective for given variable values.\n\n        Args:\n            x: The values of the variables to be evaluated.\n\n        Returns:\n            The value of the gradient of the quadratic objective given the variable values.\n\n        Raises:\n            QiskitOptimizationError: if the shape of the objective function does not match with\n                the number of variables.\n        \"\"\"\n        n = self.quadratic_program.get_num_vars()\n        if self.linear.coefficients.shape != (\n            1,\n            n,\n        ) or self.quadratic.coefficients.shape != (n, n):\n            raise QiskitOptimizationError(\n                \"The shape of the objective function does not match with the number of variables. \"\n                \"Need to define the objective function after defining all variables\"\n            )\n        return self.linear.evaluate_gradient(x) + self.quadratic.evaluate_gradient(x)\n\n    def __repr__(self):\n        # pylint: disable=cyclic-import\n        from ..translators.prettyprint import expr2str, DEFAULT_TRUNCATE\n\n        expr_str = expr2str(\n            self.constant, self.linear, self.quadratic, DEFAULT_TRUNCATE\n        )\n        return f\"&lt;{self.__class__.__name__}: {self._sense.name.lower()} {expr_str}&gt;\"\n\n    def __str__(self):\n        # pylint: disable=cyclic-import\n        from ..translators.prettyprint import expr2str\n\n        expr_str = expr2str(self.constant, self.linear, self.quadratic)\n        return f\"{self._sense.name.lower()} {expr_str}\"\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticObjective/#q3as.quadratic.QuadraticObjective.constant","title":"<code>constant: float</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the constant part of the objective function.</p> <p>Returns:</p> Type Description <code>float</code> <p>The constant part of the objective function.</p>"},{"location":"reference/q3as.quadratic/QuadraticObjective/#q3as.quadratic.QuadraticObjective.linear","title":"<code>linear: LinearExpression</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the linear part of the objective function.</p> <p>Returns:</p> Type Description <code>LinearExpression</code> <p>The linear part of the objective function.</p>"},{"location":"reference/q3as.quadratic/QuadraticObjective/#q3as.quadratic.QuadraticObjective.quadratic","title":"<code>quadratic: QuadraticExpression</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the quadratic part of the objective function.</p> <p>Returns:</p> Type Description <code>QuadraticExpression</code> <p>The quadratic part of the objective function.</p>"},{"location":"reference/q3as.quadratic/QuadraticObjective/#q3as.quadratic.QuadraticObjective.sense","title":"<code>sense: ObjSense</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the sense of the objective function.</p> <p>Returns:</p> Type Description <code>ObjSense</code> <p>The sense of the objective function.</p>"},{"location":"reference/q3as.quadratic/QuadraticObjective/#q3as.quadratic.QuadraticObjective.__init__","title":"<code>__init__(quadratic_program, constant=0.0, linear=None, quadratic=None, sense=ObjSense.MINIMIZE)</code>","text":"<p>Constructs a quadratic objective function.</p> <p>Parameters:</p> Name Type Description Default <code>quadratic_program</code> <code>Any</code> <p>The parent quadratic program.</p> required <code>constant</code> <code>float</code> <p>The constant offset of the objective.</p> <code>0.0</code> <code>linear</code> <code>Optional[Union[ndarray, spmatrix, List[float], Dict[Union[str, int], float]]]</code> <p>The coefficients of the linear part of the objective.</p> <code>None</code> <code>quadratic</code> <code>Optional[Union[ndarray, spmatrix, List[List[float]], Dict[Tuple[Union[int, str], Union[int, str]], float]]]</code> <p>The coefficients of the quadratic part of the objective.</p> <code>None</code> <code>sense</code> <code>ObjSense</code> <p>The optimization sense of the objective.</p> <code>MINIMIZE</code> Source code in <code>q3as/quadratic/problems/quadratic_objective.py</code> <pre><code>def __init__(\n    self,\n    quadratic_program: Any,\n    constant: float = 0.0,\n    linear: Optional[\n        Union[ndarray, spmatrix, List[float], Dict[Union[str, int], float]]\n    ] = None,\n    quadratic: Optional[\n        Union[\n            ndarray,\n            spmatrix,\n            List[List[float]],\n            Dict[Tuple[Union[int, str], Union[int, str]], float],\n        ]\n    ] = None,\n    sense: ObjSense = ObjSense.MINIMIZE,\n) -&gt; None:\n    \"\"\"Constructs a quadratic objective function.\n\n    Args:\n        quadratic_program: The parent quadratic program.\n        constant: The constant offset of the objective.\n        linear: The coefficients of the linear part of the objective.\n        quadratic: The coefficients of the quadratic part of the objective.\n        sense: The optimization sense of the objective.\n    \"\"\"\n    super().__init__(quadratic_program)\n    self._constant = constant\n    if linear is None:\n        linear = {}\n    self._linear = LinearExpression(quadratic_program, linear)\n    if quadratic is None:\n        quadratic = {}\n    self._quadratic = QuadraticExpression(quadratic_program, quadratic)\n    self._sense = sense\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticObjective/#q3as.quadratic.QuadraticObjective.evaluate","title":"<code>evaluate(x)</code>","text":"<p>Evaluate the quadratic objective for given variable values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ndarray, List, Dict[Union[int, str], float]]</code> <p>The values of the variables to be evaluated.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value of the quadratic objective given the variable values.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if the shape of the objective function does not match with the number of variables.</p> Source code in <code>q3as/quadratic/problems/quadratic_objective.py</code> <pre><code>def evaluate(self, x: Union[ndarray, List, Dict[Union[int, str], float]]) -&gt; float:\n    \"\"\"Evaluate the quadratic objective for given variable values.\n\n    Args:\n        x: The values of the variables to be evaluated.\n\n    Returns:\n        The value of the quadratic objective given the variable values.\n\n    Raises:\n        QiskitOptimizationError: if the shape of the objective function does not match with\n            the number of variables.\n    \"\"\"\n    n = self.quadratic_program.get_num_vars()\n    if self.linear.coefficients.shape != (\n        1,\n        n,\n    ) or self.quadratic.coefficients.shape != (n, n):\n        raise QiskitOptimizationError(\n            \"The shape of the objective function does not match with the number of variables. \"\n            \"Need to define the objective function after defining all variables\"\n        )\n    return self.constant + self.linear.evaluate(x) + self.quadratic.evaluate(x)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticObjective/#q3as.quadratic.QuadraticObjective.evaluate_gradient","title":"<code>evaluate_gradient(x)</code>","text":"<p>Evaluate the gradient of the quadratic objective for given variable values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ndarray, List, Dict[Union[int, str], float]]</code> <p>The values of the variables to be evaluated.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The value of the gradient of the quadratic objective given the variable values.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if the shape of the objective function does not match with the number of variables.</p> Source code in <code>q3as/quadratic/problems/quadratic_objective.py</code> <pre><code>def evaluate_gradient(\n    self, x: Union[ndarray, List, Dict[Union[int, str], float]]\n) -&gt; ndarray:\n    \"\"\"Evaluate the gradient of the quadratic objective for given variable values.\n\n    Args:\n        x: The values of the variables to be evaluated.\n\n    Returns:\n        The value of the gradient of the quadratic objective given the variable values.\n\n    Raises:\n        QiskitOptimizationError: if the shape of the objective function does not match with\n            the number of variables.\n    \"\"\"\n    n = self.quadratic_program.get_num_vars()\n    if self.linear.coefficients.shape != (\n        1,\n        n,\n    ) or self.quadratic.coefficients.shape != (n, n):\n        raise QiskitOptimizationError(\n            \"The shape of the objective function does not match with the number of variables. \"\n            \"Need to define the objective function after defining all variables\"\n        )\n    return self.linear.evaluate_gradient(x) + self.quadratic.evaluate_gradient(x)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/","title":"QuadraticProgram","text":"<p>Quadratically Constrained Quadratic Program representation.</p> <p>This representation supports inequality and equality constraints, as well as continuous, binary, and integer variables.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>class QuadraticProgram:\n    \"\"\"Quadratically Constrained Quadratic Program representation.\n\n    This representation supports inequality and equality constraints,\n    as well as continuous, binary, and integer variables.\n    \"\"\"\n\n    Status = QuadraticProgramStatus\n\n    def __init__(self, name: str = \"\") -&gt; None:\n        \"\"\"\n        Args:\n            name: The name of the quadratic program.\n        \"\"\"\n        if not name.isprintable():\n            warn(\"Problem name is not printable\")\n        self._name = \"\"\n        self.name = name\n        self._status = QuadraticProgram.Status.VALID\n\n        self._variables: List[Variable] = []\n        self._variables_index: Dict[str, int] = {}\n\n        self._linear_constraints: List[LinearConstraint] = []\n        self._linear_constraints_index: Dict[str, int] = {}\n\n        self._quadratic_constraints: List[QuadraticConstraint] = []\n        self._quadratic_constraints_index: Dict[str, int] = {}\n\n        self._objective = QuadraticObjective(self)\n\n    def __repr__(self) -&gt; str:\n        from ..translators.prettyprint import DEFAULT_TRUNCATE, expr2str\n\n        objective = expr2str(\n            constant=self._objective.constant,\n            linear=self.objective.linear,\n            quadratic=self._objective.quadratic,\n            truncate=DEFAULT_TRUNCATE,\n        )\n        num_constraints = (\n            self.get_num_linear_constraints() + self.get_num_quadratic_constraints()\n        )\n        return (\n            f\"&lt;{self.__class__.__name__}: \"\n            f\"{self.objective.sense.name.lower()} \"\n            f\"{objective}, \"\n            f\"{self.get_num_vars()} variables, \"\n            f\"{num_constraints} constraints, \"\n            f\"'{self._name}'&gt;\"\n        )\n\n    def __str__(self) -&gt; str:\n        num_constraints = (\n            self.get_num_linear_constraints() + self.get_num_quadratic_constraints()\n        )\n        return (\n            f\"{str(self.objective)} \"\n            f\"({self.get_num_vars()} variables, \"\n            f\"{num_constraints} constraints, \"\n            f\"'{self._name}')\"\n        )\n\n    def clear(self) -&gt; None:\n        \"\"\"Clears the quadratic program, i.e., deletes all variables, constraints, the\n        objective function as well as the name.\n        \"\"\"\n        self._name = \"\"\n        self._status = QuadraticProgram.Status.VALID\n\n        self._variables.clear()\n        self._variables_index.clear()\n\n        self._linear_constraints.clear()\n        self._linear_constraints_index.clear()\n\n        self._quadratic_constraints.clear()\n        self._quadratic_constraints_index.clear()\n\n        self._objective = QuadraticObjective(self)\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Returns the name of the quadratic program.\n\n        Returns:\n            The name of the quadratic program.\n        \"\"\"\n        return self._name\n\n    @name.setter\n    def name(self, name: str) -&gt; None:\n        \"\"\"Sets the name of the quadratic program.\n\n        Args:\n            name: The name of the quadratic program.\n        \"\"\"\n        self._check_name(name, \"Problem\")\n        self._name = name\n\n    @property\n    def status(self) -&gt; QuadraticProgramStatus:\n        \"\"\"Status of the quadratic program.\n        It can be infeasible due to variable substitution.\n\n        Returns:\n            The status of the quadratic program\n        \"\"\"\n        return self._status\n\n    @property\n    def variables(self) -&gt; List[Variable]:\n        \"\"\"Returns the list of variables of the quadratic program.\n\n        Returns:\n            List of variables.\n        \"\"\"\n        return self._variables\n\n    @property\n    def variables_index(self) -&gt; Dict[str, int]:\n        \"\"\"Returns the dictionary that maps the name of a variable to its index.\n\n        Returns:\n            The variable index dictionary.\n        \"\"\"\n        return self._variables_index\n\n    def _add_variable(\n        self,\n        lowerbound: Union[float, int],\n        upperbound: Union[float, int],\n        vartype: VarType,\n        name: Optional[str],\n    ) -&gt; Variable:\n        if not name:\n            name = \"x\"\n            key_format = \"{}\"\n        else:\n            key_format = \"\"\n        return self._add_variables(\n            1, lowerbound, upperbound, vartype, name, key_format\n        )[1][0]\n\n    def _add_variables(\n        self,\n        keys: Union[int, Sequence],\n        lowerbound: Union[float, int],\n        upperbound: Union[float, int],\n        vartype: VarType,\n        name: Optional[str],\n        key_format: str,\n    ) -&gt; Tuple[List[str], List[Variable]]:\n        if isinstance(keys, int) and keys &lt; 1:\n            raise QiskitOptimizationError(\n                f\"Cannot create non-positive number of variables: {keys}\"\n            )\n        if not name:\n            name = \"x\"\n        if \"{{}}\" in key_format:\n            raise QiskitOptimizationError(\n                f\"Formatter cannot contain nested substitutions: {key_format}\"\n            )\n        if key_format.count(\"{}\") &gt; 1:\n            raise QiskitOptimizationError(\n                f\"Formatter cannot contain more than one substitution: {key_format}\"\n            )\n\n        def _find_name(name, key_format, k):\n            prev = None\n            while True:\n                new_name = name + key_format.format(k)\n                if new_name == prev:\n                    raise QiskitOptimizationError(\n                        f\"Variable name already exists: {new_name}\"\n                    )\n                if new_name in self._variables_index:\n                    k += 1\n                    prev = new_name\n                else:\n                    break\n            return new_name, k + 1\n\n        names = []\n        variables = []\n        k = self.get_num_vars()\n        lst = keys if isinstance(keys, Sequence) else range(keys)\n        for key in lst:\n            if isinstance(keys, Sequence):\n                indexed_name = name + key_format.format(key)\n            else:\n                indexed_name, k = _find_name(name, key_format, k)\n            if indexed_name in self._variables_index:\n                raise QiskitOptimizationError(\n                    f\"Variable name already exists: {indexed_name}\"\n                )\n            self._check_name(indexed_name, \"Variable\")\n            names.append(indexed_name)\n            self._variables_index[indexed_name] = self.get_num_vars()\n            variable = Variable(self, indexed_name, lowerbound, upperbound, vartype)\n            self._variables.append(variable)\n            variables.append(variable)\n        return names, variables\n\n    def _var_dict(\n        self,\n        keys: Union[int, Sequence],\n        lowerbound: Union[float, int],\n        upperbound: Union[float, int],\n        vartype: VarType,\n        name: Optional[str],\n        key_format: str,\n    ) -&gt; Dict[str, Variable]:\n        \"\"\"\n        Adds a positive number of variables to the variable list and index and returns a\n        dictionary mapping the variable names to their instances. If 'key_format' is present,\n        the next 'var_count' available indices are substituted into 'key_format' and appended\n        to 'name'.\n\n        Args:\n            lowerbound: The lower bound of the variable(s).\n            upperbound: The upper bound of the variable(s).\n            vartype: The type of the variable(s).\n            name: The name(s) of the variable(s).\n            key_format: The format used to name/index the variable(s).\n            keys: If keys: int, it is interpreted as the number of variables to construct.\n                  Otherwise, the elements of the sequence are converted to strings via 'str' and\n                  substituted into `key_format`.\n\n        Returns:\n            A dictionary mapping the variable names to variable instances.\n\n        Raises:\n            QiskitOptimizationError: if the variable name is already taken.\n            QiskitOptimizationError: if less than one variable instantiation is attempted.\n            QiskitOptimizationError: if `key_format` has more than one substitution or a\n                                     nested substitution.\n        \"\"\"\n        return dict(\n            zip(\n                *self._add_variables(\n                    keys, lowerbound, upperbound, vartype, name, key_format\n                )\n            )\n        )\n\n    def _var_list(\n        self,\n        keys: Union[int, Sequence],\n        lowerbound: Union[float, int],\n        upperbound: Union[float, int],\n        vartype: VarType,\n        name: Optional[str],\n        key_format: str,\n    ) -&gt; List[Variable]:\n        \"\"\"\n        Adds a positive number of variables to the variable list and index and returns a\n        list of variable instances.\n\n        Args:\n            lowerbound: The lower bound of the variable(s).\n            upperbound: The upper bound of the variable(s).\n            vartype: The type of the variable(s).\n            name: The name(s) of the variable(s).\n            key_format: The format used to name/index the variable(s).\n            keys: If keys: int, it is interpreted as the number of variables to construct.\n                  Otherwise, the elements of the sequence are converted to strings via 'str' and\n                  substituted into `key_format`.\n\n        Returns:\n            A dictionary mapping the variable names to variable instances.\n\n        Raises:\n            QiskitOptimizationError: if the variable name is already taken.\n            QiskitOptimizationError: if less than one variable instantiation is attempted.\n            QiskitOptimizationError: if `key_format` has more than one substitution or a\n                                     nested substitution.\n        \"\"\"\n        return self._add_variables(\n            keys, lowerbound, upperbound, vartype, name, key_format\n        )[1]\n\n    def continuous_var(\n        self,\n        lowerbound: Union[float, int] = 0,\n        upperbound: Union[float, int] = INFINITY,\n        name: Optional[str] = None,\n    ) -&gt; Variable:\n        \"\"\"Adds a continuous variable to the quadratic program.\n\n        Args:\n            lowerbound: The lowerbound of the variable.\n            upperbound: The upperbound of the variable.\n            name: The name of the variable.\n                If it's ``None`` or empty ``\"\"``, the default name, e.g., ``x0``, is used.\n\n        Returns:\n            The added variable.\n\n        Raises:\n            QiskitOptimizationError: if the variable name is already occupied.\n        \"\"\"\n        return self._add_variable(\n            lowerbound, upperbound, Variable.Type.CONTINUOUS, name\n        )\n\n    def continuous_var_dict(\n        self,\n        keys: Union[int, Sequence],\n        lowerbound: Union[float, int] = 0,\n        upperbound: Union[float, int] = INFINITY,\n        name: Optional[str] = None,\n        key_format: str = \"{}\",\n    ) -&gt; Dict[str, Variable]:\n        \"\"\"\n        Uses 'var_dict' to construct a dictionary of continuous variables\n\n        Args:\n            lowerbound: The lower bound of the variable(s).\n            upperbound: The upper bound of the variable(s).\n            name: The name(s) of the variable(s).\n                If it's ``None`` or empty ``\"\"``, the default name, e.g., ``x0``, is used.\n            key_format: The format used to name/index the variable(s).\n            keys: If keys: int, it is interpreted as the number of variables to construct.\n                  Otherwise, the elements of the sequence are converted to strings via 'str' and\n                  substituted into `key_format`.\n\n        Returns:\n            A dictionary mapping the variable names to variable instances.\n\n        Raises:\n            QiskitOptimizationError: if the variable name is already taken.\n            QiskitOptimizationError: if less than one variable instantiation is attempted.\n            QiskitOptimizationError: if `key_format` has more than one substitution or a\n                                     nested substitution.\n        \"\"\"\n        return self._var_dict(\n            keys, lowerbound, upperbound, Variable.Type.CONTINUOUS, name, key_format\n        )\n\n    def continuous_var_list(\n        self,\n        keys: Union[int, Sequence],\n        lowerbound: Union[float, int] = 0,\n        upperbound: Union[float, int] = INFINITY,\n        name: Optional[str] = None,\n        key_format: str = \"{}\",\n    ) -&gt; List[Variable]:\n        \"\"\"\n        Uses 'var_list' to construct a list of continuous variables\n\n        Args:\n            lowerbound: The lower bound of the variable(s).\n            upperbound: The upper bound of the variable(s).\n            name: The name(s) of the variable(s).\n                If it's ``None`` or empty ``\"\"``, the default name, e.g., ``x0``, is used.\n            key_format: The format used to name/index the variable(s).\n            keys: If keys: int, it is interpreted as the number of variables to construct.\n                  Otherwise, the elements of the sequence are converted to strings via 'str' and\n                  substituted into `key_format`.\n\n        Returns:\n            A list of variable instances.\n\n        Raises:\n            QiskitOptimizationError: if the variable name is already taken.\n            QiskitOptimizationError: if less than one variable instantiation is attempted.\n            QiskitOptimizationError: if `key_format` has more than one substitution or a\n                                     nested substitution.\n        \"\"\"\n        return self._var_list(\n            keys, lowerbound, upperbound, Variable.Type.CONTINUOUS, name, key_format\n        )\n\n    def binary_var(self, name: Optional[str] = None) -&gt; Variable:\n        \"\"\"Adds a binary variable to the quadratic program.\n\n        Args:\n            name: The name of the variable.\n                If it's ``None`` or empty ``\"\"``, the default name, e.g., ``x0``, is used.\n\n        Returns:\n            The added variable.\n\n        Raises:\n            QiskitOptimizationError: if the variable name is already occupied.\n        \"\"\"\n        return self._add_variable(0, 1, Variable.Type.BINARY, name)\n\n    def binary_var_dict(\n        self,\n        keys: Union[int, Sequence],\n        name: Optional[str] = None,\n        key_format: str = \"{}\",\n    ) -&gt; Dict[str, Variable]:\n        \"\"\"\n        Uses 'var_dict' to construct a dictionary of binary variables\n\n        Args:\n            name: The name(s) of the variable(s).\n                If it's ``None`` or empty ``\"\"``, the default name, e.g., ``x0``, is used.\n            key_format: The format used to name/index the variable(s).\n            keys: If keys: int, it is interpreted as the number of variables to construct.\n                  Otherwise, the elements of the sequence are converted to strings via 'str' and\n                  substituted into `key_format`.\n\n        Returns:\n            A dictionary mapping the variable names to variable instances.\n\n        Raises:\n            QiskitOptimizationError: if the variable name is already taken.\n            QiskitOptimizationError: if less than one variable instantiation is attempted.\n            QiskitOptimizationError: if `key_format` has more than one substitution or a\n                                     nested substitution.\n        \"\"\"\n        return self._var_dict(keys, 0, 1, Variable.Type.BINARY, name, key_format)\n\n    def binary_var_list(\n        self,\n        keys: Union[int, Sequence],\n        name: Optional[str] = None,\n        key_format: str = \"{}\",\n    ) -&gt; List[Variable]:\n        \"\"\"\n        Uses 'var_list' to construct a list of binary variables\n\n        Args:\n            name: The name(s) of the variable(s).\n                If it's ``None`` or empty ``\"\"``, the default name, e.g., ``x0``, is used.\n            key_format: The format used to name/index the variable(s).\n            keys: If keys: int, it is interpreted as the number of variables to construct.\n                  Otherwise, the elements of the sequence are converted to strings via 'str' and\n                  substituted into `key_format`.\n\n        Returns:\n            A list of variable instances.\n\n        Raises:\n            QiskitOptimizationError: if the variable name is already taken.\n            QiskitOptimizationError: if less than one variable instantiation is attempted.\n            QiskitOptimizationError: if `key_format` has more than one substitution or a\n                                     nested substitution.\n        \"\"\"\n        return self._var_list(keys, 0, 1, Variable.Type.BINARY, name, key_format)\n\n    def integer_var(\n        self,\n        lowerbound: Union[float, int] = 0,\n        upperbound: Union[float, int] = INFINITY,\n        name: Optional[str] = None,\n    ) -&gt; Variable:\n        \"\"\"Adds an integer variable to the quadratic program.\n\n        Args:\n            lowerbound: The lowerbound of the variable.\n            upperbound: The upperbound of the variable.\n            name: The name of the variable.\n                If it's ``None`` or empty ``\"\"``, the default name, e.g., ``x0``, is used.\n\n        Returns:\n            The added variable.\n\n        Raises:\n            QiskitOptimizationError: if the variable name is already occupied.\n        \"\"\"\n        return self._add_variable(lowerbound, upperbound, Variable.Type.INTEGER, name)\n\n    def integer_var_dict(\n        self,\n        keys: Union[int, Sequence],\n        lowerbound: Union[float, int] = 0,\n        upperbound: Union[float, int] = INFINITY,\n        name: Optional[str] = None,\n        key_format: str = \"{}\",\n    ) -&gt; Dict[str, Variable]:\n        \"\"\"\n        Uses 'var_dict' to construct a dictionary of integer variables\n\n        Args:\n            lowerbound: The lower bound of the variable(s).\n            upperbound: The upper bound of the variable(s).\n            name: The name(s) of the variable(s).\n                If it's ``None`` or empty ``\"\"``, the default name, e.g., ``x0``, is used.\n            key_format: The format used to name/index the variable(s).\n            keys: If keys: int, it is interpreted as the number of variables to construct.\n                  Otherwise, the elements of the sequence are converted to strings via 'str' and\n                  substituted into `key_format`.\n\n        Returns:\n            A dictionary mapping the variable names to variable instances.\n\n        Raises:\n            QiskitOptimizationError: if the variable name is already taken.\n            QiskitOptimizationError: if less than one variable instantiation is attempted.\n            QiskitOptimizationError: if `key_format` has more than one substitution or a\n                                     nested substitution.\n        \"\"\"\n        return self._var_dict(\n            keys, lowerbound, upperbound, Variable.Type.INTEGER, name, key_format\n        )\n\n    def integer_var_list(\n        self,\n        keys: Union[int, Sequence],\n        lowerbound: Union[float, int] = 0,\n        upperbound: Union[float, int] = INFINITY,\n        name: Optional[str] = None,\n        key_format: str = \"{}\",\n    ) -&gt; List[Variable]:\n        \"\"\"\n        Uses 'var_list' to construct a list of integer variables\n\n        Args:\n            lowerbound: The lower bound of the variable(s).\n            upperbound: The upper bound of the variable(s).\n            name: The name(s) of the variable(s).\n                If it's ``None`` or empty ``\"\"``, the default name, e.g., ``x0``, is used.\n            key_format: The format used to name/index the variable(s).\n            keys: If keys: int, it is interpreted as the number of variables to construct.\n                  Otherwise, the elements of the sequence are converted to strings via 'str' and\n                  substituted into `key_format`.\n\n        Returns:\n            A list of variable instances.\n\n        Raises:\n            QiskitOptimizationError: if the variable name is already taken.\n            QiskitOptimizationError: if less than one variable instantiation is attempted.\n            QiskitOptimizationError: if `key_format` has more than one substitution or a\n                                     nested substitution.\n        \"\"\"\n        return self._var_list(\n            keys, lowerbound, upperbound, Variable.Type.INTEGER, name, key_format\n        )\n\n    def get_variable(self, i: Union[int, str]) -&gt; Variable:\n        \"\"\"Returns a variable for a given name or index.\n\n        Args:\n            i: the index or name of the variable.\n\n        Returns:\n            The corresponding variable.\n        \"\"\"\n        if isinstance(i, (int, np.integer)):\n            return self.variables[i]\n        else:\n            return self.variables[self._variables_index[i]]\n\n    def get_num_vars(self, vartype: Optional[VarType] = None) -&gt; int:\n        \"\"\"Returns the total number of variables or the number of variables of the specified type.\n\n        Args:\n            vartype: The type to be filtered on. All variables are counted if None.\n\n        Returns:\n            The total number of variables.\n        \"\"\"\n        if vartype:\n            return sum(variable.vartype == vartype for variable in self._variables)\n        else:\n            return len(self._variables)\n\n    def get_num_continuous_vars(self) -&gt; int:\n        \"\"\"Returns the total number of continuous variables.\n\n        Returns:\n            The total number of continuous variables.\n        \"\"\"\n        return self.get_num_vars(Variable.Type.CONTINUOUS)\n\n    def get_num_binary_vars(self) -&gt; int:\n        \"\"\"Returns the total number of binary variables.\n\n        Returns:\n            The total number of binary variables.\n        \"\"\"\n        return self.get_num_vars(Variable.Type.BINARY)\n\n    def get_num_integer_vars(self) -&gt; int:\n        \"\"\"Returns the total number of integer variables.\n\n        Returns:\n            The total number of integer variables.\n        \"\"\"\n        return self.get_num_vars(Variable.Type.INTEGER)\n\n    @property\n    def linear_constraints(self) -&gt; List[LinearConstraint]:\n        \"\"\"Returns the list of linear constraints of the quadratic program.\n\n        Returns:\n            List of linear constraints.\n        \"\"\"\n        return self._linear_constraints\n\n    @property\n    def linear_constraints_index(self) -&gt; Dict[str, int]:\n        \"\"\"Returns the dictionary that maps the name of a linear constraint to its index.\n\n        Returns:\n            The linear constraint index dictionary.\n        \"\"\"\n        return self._linear_constraints_index\n\n    def linear_constraint(\n        self,\n        linear: Union[\n            ndarray, spmatrix, List[float], Dict[Union[int, str], float]\n        ] = None,\n        sense: Union[str, ConstraintSense] = \"&lt;=\",\n        rhs: float = 0.0,\n        name: Optional[str] = None,\n    ) -&gt; LinearConstraint:\n        \"\"\"Adds a linear equality constraint to the quadratic program of the form:\n            ``(linear * x) sense rhs``.\n\n        Args:\n            linear: The linear coefficients of the left-hand side of the constraint.\n            sense: The sense of the constraint,\n\n                - ``==``, ``=``, ``E``, and ``EQ`` denote 'equal to'.\n                - ``&gt;=``, ``&gt;``, ``G``, and ``GE`` denote 'greater-than-or-equal-to'.\n                - ``&lt;=``, ``&lt;``, ``L``, and ``LE`` denote 'less-than-or-equal-to'.\n\n            rhs: The right-hand side of the constraint.\n            name: The name of the constraint.\n                If it's ``None`` or empty ``\"\"``, the default name, e.g., ``c0``, is used.\n\n        Returns:\n            The added constraint.\n\n        Raises:\n            QiskitOptimizationError: if the constraint name already exists or the sense is not\n                valid.\n        \"\"\"\n        if name:\n            if name in self.linear_constraints_index:\n                raise QiskitOptimizationError(\n                    f\"Linear constraint's name already exists: {name}\"\n                )\n            self._check_name(name, \"Linear constraint\")\n        else:\n            k = self.get_num_linear_constraints()\n            while f\"c{k}\" in self.linear_constraints_index:\n                k += 1\n            name = f\"c{k}\"\n        self.linear_constraints_index[name] = len(self.linear_constraints)\n        if linear is None:\n            linear = {}\n        constraint = LinearConstraint(\n            self, name, linear, Constraint.Sense.convert(sense), rhs\n        )\n        self.linear_constraints.append(constraint)\n        return constraint\n\n    def get_linear_constraint(self, i: Union[int, str]) -&gt; LinearConstraint:\n        \"\"\"Returns a linear constraint for a given name or index.\n\n        Args:\n            i: the index or name of the constraint.\n\n        Returns:\n            The corresponding constraint.\n\n        Raises:\n            IndexError: if the index is out of the list size\n            KeyError: if the name does not exist\n        \"\"\"\n        if isinstance(i, int):\n            return self._linear_constraints[i]\n        else:\n            return self._linear_constraints[self._linear_constraints_index[i]]\n\n    def get_num_linear_constraints(self) -&gt; int:\n        \"\"\"Returns the number of linear constraints.\n\n        Returns:\n            The number of linear constraints.\n        \"\"\"\n        return len(self._linear_constraints)\n\n    @property\n    def quadratic_constraints(self) -&gt; List[QuadraticConstraint]:\n        \"\"\"Returns the list of quadratic constraints of the quadratic program.\n\n        Returns:\n            List of quadratic constraints.\n        \"\"\"\n        return self._quadratic_constraints\n\n    @property\n    def quadratic_constraints_index(self) -&gt; Dict[str, int]:\n        \"\"\"Returns the dictionary that maps the name of a quadratic constraint to its index.\n\n        Returns:\n            The quadratic constraint index dictionary.\n        \"\"\"\n        return self._quadratic_constraints_index\n\n    def quadratic_constraint(\n        self,\n        linear: Union[\n            ndarray, spmatrix, List[float], Dict[Union[int, str], float]\n        ] = None,\n        quadratic: Union[\n            ndarray,\n            spmatrix,\n            List[List[float]],\n            Dict[Tuple[Union[int, str], Union[int, str]], float],\n        ] = None,\n        sense: Union[str, ConstraintSense] = \"&lt;=\",\n        rhs: float = 0.0,\n        name: Optional[str] = None,\n    ) -&gt; QuadraticConstraint:\n        \"\"\"Adds a quadratic equality constraint to the quadratic program of the form:\n            ``(x * quadratic * x + linear * x) sense rhs``.\n\n        Args:\n            linear: The linear coefficients of the constraint.\n            quadratic: The quadratic coefficients of the constraint.\n            sense: The sense of the constraint,\n\n                - ``==``, ``=``, ``E``, and ``EQ`` denote 'equal to'.\n                - ``&gt;=``, ``&gt;``, ``G``, and ``GE`` denote 'greater-than-or-equal-to'.\n                - ``&lt;=``, ``&lt;``, ``L``, and ``LE`` denote 'less-than-or-equal-to'.\n\n            rhs: The right-hand side of the constraint.\n            name: The name of the constraint.\n                If it's ``None`` or empty ``\"\"``, the default name, e.g., ``q0``, is used.\n\n        Returns:\n            The added constraint.\n\n        Raises:\n            QiskitOptimizationError: if the constraint name already exists.\n        \"\"\"\n        if name:\n            if name in self.quadratic_constraints_index:\n                raise QiskitOptimizationError(\n                    f\"Quadratic constraint name already exists: {name}\"\n                )\n            self._check_name(name, \"Quadratic constraint\")\n        else:\n            k = self.get_num_quadratic_constraints()\n            while f\"q{k}\" in self.quadratic_constraints_index:\n                k += 1\n            name = f\"q{k}\"\n        self.quadratic_constraints_index[name] = len(self.quadratic_constraints)\n        if linear is None:\n            linear = {}\n        if quadratic is None:\n            quadratic = {}\n        constraint = QuadraticConstraint(\n            self, name, linear, quadratic, Constraint.Sense.convert(sense), rhs\n        )\n        self.quadratic_constraints.append(constraint)\n        return constraint\n\n    def get_quadratic_constraint(self, i: Union[int, str]) -&gt; QuadraticConstraint:\n        \"\"\"Returns a quadratic constraint for a given name or index.\n\n        Args:\n            i: the index or name of the constraint.\n\n        Returns:\n            The corresponding constraint.\n\n        Raises:\n            IndexError: if the index is out of the list size\n            KeyError: if the name does not exist\n        \"\"\"\n        if isinstance(i, int):\n            return self._quadratic_constraints[i]\n        else:\n            return self._quadratic_constraints[self._quadratic_constraints_index[i]]\n\n    def get_num_quadratic_constraints(self) -&gt; int:\n        \"\"\"Returns the number of quadratic constraints.\n\n        Returns:\n            The number of quadratic constraints.\n        \"\"\"\n        return len(self._quadratic_constraints)\n\n    def remove_linear_constraint(self, i: Union[str, int]) -&gt; None:\n        \"\"\"Remove a linear constraint\n\n        Args:\n            i: an index or a name of a linear constraint\n\n        Raises:\n            KeyError: if name does not exist\n            IndexError: if index is out of range\n        \"\"\"\n        if isinstance(i, str):\n            i = self._linear_constraints_index[i]\n        del self._linear_constraints[i]\n        self._linear_constraints_index = {\n            cst.name: j for j, cst in enumerate(self._linear_constraints)\n        }\n\n    def remove_quadratic_constraint(self, i: Union[str, int]) -&gt; None:\n        \"\"\"Remove a quadratic constraint\n\n        Args:\n            i: an index or a name of a quadratic constraint\n\n        Raises:\n            KeyError: if name does not exist\n            IndexError: if index is out of range\n        \"\"\"\n        if isinstance(i, str):\n            i = self._quadratic_constraints_index[i]\n        del self._quadratic_constraints[i]\n        self._quadratic_constraints_index = {\n            cst.name: j for j, cst in enumerate(self._quadratic_constraints)\n        }\n\n    @property\n    def objective(self) -&gt; QuadraticObjective:\n        \"\"\"Returns the quadratic objective.\n\n        Returns:\n            The quadratic objective.\n        \"\"\"\n        return self._objective\n\n    def minimize(\n        self,\n        constant: float = 0.0,\n        linear: Union[\n            ndarray, spmatrix, List[float], Dict[Union[str, int], float]\n        ] = None,\n        quadratic: Union[\n            ndarray,\n            spmatrix,\n            List[List[float]],\n            Dict[Tuple[Union[int, str], Union[int, str]], float],\n        ] = None,\n    ) -&gt; None:\n        \"\"\"Sets a quadratic objective to be minimized.\n\n        Args:\n            constant: the constant offset of the objective.\n            linear: the coefficients of the linear part of the objective.\n            quadratic: the coefficients of the quadratic part of the objective.\n\n        Returns:\n            The created quadratic objective.\n        \"\"\"\n        self._objective = QuadraticObjective(\n            self, constant, linear, quadratic, QuadraticObjective.Sense.MINIMIZE\n        )\n\n    def maximize(\n        self,\n        constant: float = 0.0,\n        linear: Union[\n            ndarray, spmatrix, List[float], Dict[Union[str, int], float]\n        ] = None,\n        quadratic: Union[\n            ndarray,\n            spmatrix,\n            List[List[float]],\n            Dict[Tuple[Union[int, str], Union[int, str]], float],\n        ] = None,\n    ) -&gt; None:\n        \"\"\"Sets a quadratic objective to be maximized.\n\n        Args:\n            constant: the constant offset of the objective.\n            linear: the coefficients of the linear part of the objective.\n            quadratic: the coefficients of the quadratic part of the objective.\n\n        Returns:\n            The created quadratic objective.\n        \"\"\"\n        self._objective = QuadraticObjective(\n            self, constant, linear, quadratic, QuadraticObjective.Sense.MAXIMIZE\n        )\n\n    def _copy_from(self, other: \"QuadraticProgram\", include_name: bool) -&gt; None:\n        \"\"\"Copy another QuadraticProgram to this updating QuadraticProgramElement\n\n        Note: this breaks the consistency of `other`. You cannot use `other` after the copy.\n\n        Args:\n            other: The quadratic program to be copied from.\n            include_name: Whether this method copies the problem name or not.\n        \"\"\"\n        for attr, val in vars(other).items():\n            if attr == \"_name\" and not include_name:\n                continue\n            if isinstance(val, QuadraticProgramElement):\n                val.quadratic_program = self\n            if isinstance(val, list):\n                for elem in val:\n                    if isinstance(elem, QuadraticProgramElement):\n                        elem.quadratic_program = self\n            setattr(self, attr, val)\n\n    def substitute_variables(\n        self,\n        constants: Optional[Dict[Union[str, int], float]] = None,\n        variables: Optional[\n            Dict[Union[str, int], Tuple[Union[str, int], float]]\n        ] = None,\n    ) -&gt; \"QuadraticProgram\":\n        \"\"\"Substitutes variables with constants or other variables.\n\n        Args:\n            constants: replace variable by constant\n                e.g., ``{'x': 2}`` means ``x`` is substituted with 2\n\n            variables: replace variables by weighted other variable\n                need to copy everything using name reference to make sure that indices are matched\n                correctly. The lower and upper bounds are updated accordingly.\n                e.g., ``{'x': ('y', 2)}`` means ``x`` is substituted with ``y * 2``\n\n        Returns:\n            An optimization problem by substituting variables with constants or other variables.\n            If the substitution is valid, ``QuadraticProgram.status`` is still\n            ``QuadraticProgram.Status.VALID``.\n            Otherwise, it gets ``QuadraticProgram.Status.INFEASIBLE``.\n\n        Raises:\n            QiskitOptimizationError: if the substitution is invalid as follows.\n\n                - Same variable is substituted multiple times.\n                - Coefficient of variable substitution is zero.\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from .substitute_variables import substitute_variables\n\n        return substitute_variables(self, constants, variables)\n\n    def to_ising(self) -&gt; Tuple[SparsePauliOp, float]:\n        \"\"\"Return the Ising Hamiltonian of this problem.\n\n        Variables are mapped to qubits in the same order, i.e.,\n        i-th variable is mapped to i-th qubit.\n        See https://github.com/Qiskit/qiskit-terra/issues/1148 for details.\n\n        Returns:\n            qubit_op: The qubit operator for the problem\n            offset: The constant value in the Ising Hamiltonian.\n\n        Raises:\n            QiskitOptimizationError: If a variable type is not binary.\n            QiskitOptimizationError: If constraints exist in the problem.\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from ..translators.ising import to_ising\n\n        return to_ising(self)\n\n    def from_ising(\n        self,\n        qubit_op: BaseOperator,\n        offset: float = 0.0,\n        linear: bool = False,\n    ) -&gt; None:\n        r\"\"\"Create a quadratic program from a qubit operator and a shift value.\n\n        Variables are mapped to qubits in the same order, i.e.,\n        i-th variable is mapped to i-th qubit.\n        See https://github.com/Qiskit/qiskit-terra/issues/1148 for details.\n\n        Args:\n            qubit_op: The qubit operator of the problem.\n            offset: The constant value in the Ising Hamiltonian.\n            linear: If linear is True, :math:`x^2` is treated as a linear term\n                since :math:`x^2 = x` for :math:`x \\in \\{0,1\\}`.\n                Else, :math:`x^2` is treated as a quadratic term.\n                The default value is False.\n\n        Raises:\n            QiskitOptimizationError: If there are Pauli Xs in any Pauli term\n            QiskitOptimizationError: If there are more than 2 Pauli Zs in any Pauli term\n            NotImplementedError: If the input operator is a ListOp\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from ..translators.ising import from_ising\n\n        other = from_ising(qubit_op, offset, linear)\n        self._copy_from(other, include_name=False)\n\n    def get_feasibility_info(\n        self, x: Union[List[float], np.ndarray]\n    ) -&gt; Tuple[bool, List[Variable], List[Constraint]]:\n        \"\"\"Returns whether a solution is feasible or not along with the violations.\n        Args:\n            x: a solution value, such as returned in an optimizer result.\n        Returns:\n            feasible: Whether the solution provided is feasible or not.\n            List[Variable]: List of variables which are violated.\n            List[Constraint]: List of constraints which are violated.\n\n        Raises:\n            QiskitOptimizationError: If the input `x` is not same len as total vars\n        \"\"\"\n        # if input `x` is not the same len as the total vars, raise an error\n        if len(x) != self.get_num_vars():\n            raise QiskitOptimizationError(\n                f\"The size of solution `x`: {len(x)}, does not match the number of problem variables: \"\n                f\"{self.get_num_vars()}\"\n            )\n\n        # check whether the input satisfy the bounds of the problem\n        violated_variables = []\n        for i, val in enumerate(x):\n            variable = self.get_variable(i)\n            if val &lt; variable.lowerbound or variable.upperbound &lt; val:\n                violated_variables.append(variable)\n\n        # check whether the input satisfy the constraints of the problem\n        violated_constraints = []\n        for constraint in cast(List[Constraint], self._linear_constraints) + cast(\n            List[Constraint], self._quadratic_constraints\n        ):\n            lhs = constraint.evaluate(x)\n            if constraint.sense == ConstraintSense.LE and lhs &gt; constraint.rhs:\n                violated_constraints.append(constraint)\n            elif constraint.sense == ConstraintSense.GE and lhs &lt; constraint.rhs:\n                violated_constraints.append(constraint)\n            elif constraint.sense == ConstraintSense.EQ and not isclose(\n                lhs, constraint.rhs\n            ):\n                violated_constraints.append(constraint)\n\n        feasible = not violated_variables and not violated_constraints\n\n        return feasible, violated_variables, violated_constraints\n\n    def is_feasible(self, x: Union[List[float], np.ndarray]) -&gt; bool:\n        \"\"\"Returns whether a solution is feasible or not.\n\n        Args:\n            x: a solution value, such as returned in an optimizer result.\n\n        Returns:\n            ``True`` if the solution provided is feasible otherwise ``False``.\n\n        \"\"\"\n        feasible, _, _ = self.get_feasibility_info(x)\n\n        return feasible\n\n    def prettyprint(self, wrap: int = 80) -&gt; str:\n        \"\"\"Returns a pretty printed string of this problem.\n\n        Args:\n            wrap: The text width to wrap the output strings. It is disabled by setting 0.\n                Note that some strings might exceed this value, for example, a long variable\n                name won't be wrapped. The default value is 80.\n\n        Returns:\n            A pretty printed string representing the problem.\n\n        Raises:\n            QiskitOptimizationError: if there is a non-printable name.\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from ..translators.prettyprint import prettyprint\n\n        return prettyprint(self, wrap)\n\n    @staticmethod\n    def _check_name(name: str, name_type: str) -&gt; None:\n        \"\"\"Displays a warning message if a name string is not printable\"\"\"\n        if not name.isprintable():\n            warn(f\"{name_type} name is not printable: {repr(name)}\")\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.linear_constraints","title":"<code>linear_constraints: List[LinearConstraint]</code>  <code>property</code>","text":"<p>Returns the list of linear constraints of the quadratic program.</p> <p>Returns:</p> Type Description <code>List[LinearConstraint]</code> <p>List of linear constraints.</p>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.linear_constraints_index","title":"<code>linear_constraints_index: Dict[str, int]</code>  <code>property</code>","text":"<p>Returns the dictionary that maps the name of a linear constraint to its index.</p> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>The linear constraint index dictionary.</p>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.name","title":"<code>name: str</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the name of the quadratic program.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the quadratic program.</p>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.objective","title":"<code>objective: QuadraticObjective</code>  <code>property</code>","text":"<p>Returns the quadratic objective.</p> <p>Returns:</p> Type Description <code>QuadraticObjective</code> <p>The quadratic objective.</p>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.quadratic_constraints","title":"<code>quadratic_constraints: List[QuadraticConstraint]</code>  <code>property</code>","text":"<p>Returns the list of quadratic constraints of the quadratic program.</p> <p>Returns:</p> Type Description <code>List[QuadraticConstraint]</code> <p>List of quadratic constraints.</p>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.quadratic_constraints_index","title":"<code>quadratic_constraints_index: Dict[str, int]</code>  <code>property</code>","text":"<p>Returns the dictionary that maps the name of a quadratic constraint to its index.</p> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>The quadratic constraint index dictionary.</p>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.status","title":"<code>status: QuadraticProgramStatus</code>  <code>property</code>","text":"<p>Status of the quadratic program. It can be infeasible due to variable substitution.</p> <p>Returns:</p> Type Description <code>QuadraticProgramStatus</code> <p>The status of the quadratic program</p>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.variables","title":"<code>variables: List[Variable]</code>  <code>property</code>","text":"<p>Returns the list of variables of the quadratic program.</p> <p>Returns:</p> Type Description <code>List[Variable]</code> <p>List of variables.</p>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.variables_index","title":"<code>variables_index: Dict[str, int]</code>  <code>property</code>","text":"<p>Returns the dictionary that maps the name of a variable to its index.</p> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>The variable index dictionary.</p>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.__init__","title":"<code>__init__(name='')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the quadratic program.</p> <code>''</code> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def __init__(self, name: str = \"\") -&gt; None:\n    \"\"\"\n    Args:\n        name: The name of the quadratic program.\n    \"\"\"\n    if not name.isprintable():\n        warn(\"Problem name is not printable\")\n    self._name = \"\"\n    self.name = name\n    self._status = QuadraticProgram.Status.VALID\n\n    self._variables: List[Variable] = []\n    self._variables_index: Dict[str, int] = {}\n\n    self._linear_constraints: List[LinearConstraint] = []\n    self._linear_constraints_index: Dict[str, int] = {}\n\n    self._quadratic_constraints: List[QuadraticConstraint] = []\n    self._quadratic_constraints_index: Dict[str, int] = {}\n\n    self._objective = QuadraticObjective(self)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.binary_var","title":"<code>binary_var(name=None)</code>","text":"<p>Adds a binary variable to the quadratic program.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the variable. If it's <code>None</code> or empty <code>\"\"</code>, the default name, e.g., <code>x0</code>, is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The added variable.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if the variable name is already occupied.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def binary_var(self, name: Optional[str] = None) -&gt; Variable:\n    \"\"\"Adds a binary variable to the quadratic program.\n\n    Args:\n        name: The name of the variable.\n            If it's ``None`` or empty ``\"\"``, the default name, e.g., ``x0``, is used.\n\n    Returns:\n        The added variable.\n\n    Raises:\n        QiskitOptimizationError: if the variable name is already occupied.\n    \"\"\"\n    return self._add_variable(0, 1, Variable.Type.BINARY, name)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.binary_var_dict","title":"<code>binary_var_dict(keys, name=None, key_format='{}')</code>","text":"<p>Uses 'var_dict' to construct a dictionary of binary variables</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name(s) of the variable(s). If it's <code>None</code> or empty <code>\"\"</code>, the default name, e.g., <code>x0</code>, is used.</p> <code>None</code> <code>key_format</code> <code>str</code> <p>The format used to name/index the variable(s).</p> <code>'{}'</code> <code>keys</code> <code>Union[int, Sequence]</code> <p>If keys: int, it is interpreted as the number of variables to construct.   Otherwise, the elements of the sequence are converted to strings via 'str' and   substituted into <code>key_format</code>.</p> required <p>Returns:</p> Type Description <code>Dict[str, Variable]</code> <p>A dictionary mapping the variable names to variable instances.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if the variable name is already taken.</p> <code>QiskitOptimizationError</code> <p>if less than one variable instantiation is attempted.</p> <code>QiskitOptimizationError</code> <p>if <code>key_format</code> has more than one substitution or a                      nested substitution.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def binary_var_dict(\n    self,\n    keys: Union[int, Sequence],\n    name: Optional[str] = None,\n    key_format: str = \"{}\",\n) -&gt; Dict[str, Variable]:\n    \"\"\"\n    Uses 'var_dict' to construct a dictionary of binary variables\n\n    Args:\n        name: The name(s) of the variable(s).\n            If it's ``None`` or empty ``\"\"``, the default name, e.g., ``x0``, is used.\n        key_format: The format used to name/index the variable(s).\n        keys: If keys: int, it is interpreted as the number of variables to construct.\n              Otherwise, the elements of the sequence are converted to strings via 'str' and\n              substituted into `key_format`.\n\n    Returns:\n        A dictionary mapping the variable names to variable instances.\n\n    Raises:\n        QiskitOptimizationError: if the variable name is already taken.\n        QiskitOptimizationError: if less than one variable instantiation is attempted.\n        QiskitOptimizationError: if `key_format` has more than one substitution or a\n                                 nested substitution.\n    \"\"\"\n    return self._var_dict(keys, 0, 1, Variable.Type.BINARY, name, key_format)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.binary_var_list","title":"<code>binary_var_list(keys, name=None, key_format='{}')</code>","text":"<p>Uses 'var_list' to construct a list of binary variables</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name(s) of the variable(s). If it's <code>None</code> or empty <code>\"\"</code>, the default name, e.g., <code>x0</code>, is used.</p> <code>None</code> <code>key_format</code> <code>str</code> <p>The format used to name/index the variable(s).</p> <code>'{}'</code> <code>keys</code> <code>Union[int, Sequence]</code> <p>If keys: int, it is interpreted as the number of variables to construct.   Otherwise, the elements of the sequence are converted to strings via 'str' and   substituted into <code>key_format</code>.</p> required <p>Returns:</p> Type Description <code>List[Variable]</code> <p>A list of variable instances.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if the variable name is already taken.</p> <code>QiskitOptimizationError</code> <p>if less than one variable instantiation is attempted.</p> <code>QiskitOptimizationError</code> <p>if <code>key_format</code> has more than one substitution or a                      nested substitution.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def binary_var_list(\n    self,\n    keys: Union[int, Sequence],\n    name: Optional[str] = None,\n    key_format: str = \"{}\",\n) -&gt; List[Variable]:\n    \"\"\"\n    Uses 'var_list' to construct a list of binary variables\n\n    Args:\n        name: The name(s) of the variable(s).\n            If it's ``None`` or empty ``\"\"``, the default name, e.g., ``x0``, is used.\n        key_format: The format used to name/index the variable(s).\n        keys: If keys: int, it is interpreted as the number of variables to construct.\n              Otherwise, the elements of the sequence are converted to strings via 'str' and\n              substituted into `key_format`.\n\n    Returns:\n        A list of variable instances.\n\n    Raises:\n        QiskitOptimizationError: if the variable name is already taken.\n        QiskitOptimizationError: if less than one variable instantiation is attempted.\n        QiskitOptimizationError: if `key_format` has more than one substitution or a\n                                 nested substitution.\n    \"\"\"\n    return self._var_list(keys, 0, 1, Variable.Type.BINARY, name, key_format)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.clear","title":"<code>clear()</code>","text":"<p>Clears the quadratic program, i.e., deletes all variables, constraints, the objective function as well as the name.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clears the quadratic program, i.e., deletes all variables, constraints, the\n    objective function as well as the name.\n    \"\"\"\n    self._name = \"\"\n    self._status = QuadraticProgram.Status.VALID\n\n    self._variables.clear()\n    self._variables_index.clear()\n\n    self._linear_constraints.clear()\n    self._linear_constraints_index.clear()\n\n    self._quadratic_constraints.clear()\n    self._quadratic_constraints_index.clear()\n\n    self._objective = QuadraticObjective(self)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.continuous_var","title":"<code>continuous_var(lowerbound=0, upperbound=INFINITY, name=None)</code>","text":"<p>Adds a continuous variable to the quadratic program.</p> <p>Parameters:</p> Name Type Description Default <code>lowerbound</code> <code>Union[float, int]</code> <p>The lowerbound of the variable.</p> <code>0</code> <code>upperbound</code> <code>Union[float, int]</code> <p>The upperbound of the variable.</p> <code>INFINITY</code> <code>name</code> <code>Optional[str]</code> <p>The name of the variable. If it's <code>None</code> or empty <code>\"\"</code>, the default name, e.g., <code>x0</code>, is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The added variable.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if the variable name is already occupied.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def continuous_var(\n    self,\n    lowerbound: Union[float, int] = 0,\n    upperbound: Union[float, int] = INFINITY,\n    name: Optional[str] = None,\n) -&gt; Variable:\n    \"\"\"Adds a continuous variable to the quadratic program.\n\n    Args:\n        lowerbound: The lowerbound of the variable.\n        upperbound: The upperbound of the variable.\n        name: The name of the variable.\n            If it's ``None`` or empty ``\"\"``, the default name, e.g., ``x0``, is used.\n\n    Returns:\n        The added variable.\n\n    Raises:\n        QiskitOptimizationError: if the variable name is already occupied.\n    \"\"\"\n    return self._add_variable(\n        lowerbound, upperbound, Variable.Type.CONTINUOUS, name\n    )\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.continuous_var_dict","title":"<code>continuous_var_dict(keys, lowerbound=0, upperbound=INFINITY, name=None, key_format='{}')</code>","text":"<p>Uses 'var_dict' to construct a dictionary of continuous variables</p> <p>Parameters:</p> Name Type Description Default <code>lowerbound</code> <code>Union[float, int]</code> <p>The lower bound of the variable(s).</p> <code>0</code> <code>upperbound</code> <code>Union[float, int]</code> <p>The upper bound of the variable(s).</p> <code>INFINITY</code> <code>name</code> <code>Optional[str]</code> <p>The name(s) of the variable(s). If it's <code>None</code> or empty <code>\"\"</code>, the default name, e.g., <code>x0</code>, is used.</p> <code>None</code> <code>key_format</code> <code>str</code> <p>The format used to name/index the variable(s).</p> <code>'{}'</code> <code>keys</code> <code>Union[int, Sequence]</code> <p>If keys: int, it is interpreted as the number of variables to construct.   Otherwise, the elements of the sequence are converted to strings via 'str' and   substituted into <code>key_format</code>.</p> required <p>Returns:</p> Type Description <code>Dict[str, Variable]</code> <p>A dictionary mapping the variable names to variable instances.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if the variable name is already taken.</p> <code>QiskitOptimizationError</code> <p>if less than one variable instantiation is attempted.</p> <code>QiskitOptimizationError</code> <p>if <code>key_format</code> has more than one substitution or a                      nested substitution.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def continuous_var_dict(\n    self,\n    keys: Union[int, Sequence],\n    lowerbound: Union[float, int] = 0,\n    upperbound: Union[float, int] = INFINITY,\n    name: Optional[str] = None,\n    key_format: str = \"{}\",\n) -&gt; Dict[str, Variable]:\n    \"\"\"\n    Uses 'var_dict' to construct a dictionary of continuous variables\n\n    Args:\n        lowerbound: The lower bound of the variable(s).\n        upperbound: The upper bound of the variable(s).\n        name: The name(s) of the variable(s).\n            If it's ``None`` or empty ``\"\"``, the default name, e.g., ``x0``, is used.\n        key_format: The format used to name/index the variable(s).\n        keys: If keys: int, it is interpreted as the number of variables to construct.\n              Otherwise, the elements of the sequence are converted to strings via 'str' and\n              substituted into `key_format`.\n\n    Returns:\n        A dictionary mapping the variable names to variable instances.\n\n    Raises:\n        QiskitOptimizationError: if the variable name is already taken.\n        QiskitOptimizationError: if less than one variable instantiation is attempted.\n        QiskitOptimizationError: if `key_format` has more than one substitution or a\n                                 nested substitution.\n    \"\"\"\n    return self._var_dict(\n        keys, lowerbound, upperbound, Variable.Type.CONTINUOUS, name, key_format\n    )\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.continuous_var_list","title":"<code>continuous_var_list(keys, lowerbound=0, upperbound=INFINITY, name=None, key_format='{}')</code>","text":"<p>Uses 'var_list' to construct a list of continuous variables</p> <p>Parameters:</p> Name Type Description Default <code>lowerbound</code> <code>Union[float, int]</code> <p>The lower bound of the variable(s).</p> <code>0</code> <code>upperbound</code> <code>Union[float, int]</code> <p>The upper bound of the variable(s).</p> <code>INFINITY</code> <code>name</code> <code>Optional[str]</code> <p>The name(s) of the variable(s). If it's <code>None</code> or empty <code>\"\"</code>, the default name, e.g., <code>x0</code>, is used.</p> <code>None</code> <code>key_format</code> <code>str</code> <p>The format used to name/index the variable(s).</p> <code>'{}'</code> <code>keys</code> <code>Union[int, Sequence]</code> <p>If keys: int, it is interpreted as the number of variables to construct.   Otherwise, the elements of the sequence are converted to strings via 'str' and   substituted into <code>key_format</code>.</p> required <p>Returns:</p> Type Description <code>List[Variable]</code> <p>A list of variable instances.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if the variable name is already taken.</p> <code>QiskitOptimizationError</code> <p>if less than one variable instantiation is attempted.</p> <code>QiskitOptimizationError</code> <p>if <code>key_format</code> has more than one substitution or a                      nested substitution.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def continuous_var_list(\n    self,\n    keys: Union[int, Sequence],\n    lowerbound: Union[float, int] = 0,\n    upperbound: Union[float, int] = INFINITY,\n    name: Optional[str] = None,\n    key_format: str = \"{}\",\n) -&gt; List[Variable]:\n    \"\"\"\n    Uses 'var_list' to construct a list of continuous variables\n\n    Args:\n        lowerbound: The lower bound of the variable(s).\n        upperbound: The upper bound of the variable(s).\n        name: The name(s) of the variable(s).\n            If it's ``None`` or empty ``\"\"``, the default name, e.g., ``x0``, is used.\n        key_format: The format used to name/index the variable(s).\n        keys: If keys: int, it is interpreted as the number of variables to construct.\n              Otherwise, the elements of the sequence are converted to strings via 'str' and\n              substituted into `key_format`.\n\n    Returns:\n        A list of variable instances.\n\n    Raises:\n        QiskitOptimizationError: if the variable name is already taken.\n        QiskitOptimizationError: if less than one variable instantiation is attempted.\n        QiskitOptimizationError: if `key_format` has more than one substitution or a\n                                 nested substitution.\n    \"\"\"\n    return self._var_list(\n        keys, lowerbound, upperbound, Variable.Type.CONTINUOUS, name, key_format\n    )\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.from_ising","title":"<code>from_ising(qubit_op, offset=0.0, linear=False)</code>","text":"<p>Create a quadratic program from a qubit operator and a shift value.</p> <p>Variables are mapped to qubits in the same order, i.e., i-th variable is mapped to i-th qubit. See https://github.com/Qiskit/qiskit-terra/issues/1148 for details.</p> <p>Parameters:</p> Name Type Description Default <code>qubit_op</code> <code>BaseOperator</code> <p>The qubit operator of the problem.</p> required <code>offset</code> <code>float</code> <p>The constant value in the Ising Hamiltonian.</p> <code>0.0</code> <code>linear</code> <code>bool</code> <p>If linear is True, :math:<code>x^2</code> is treated as a linear term since :math:<code>x^2 = x</code> for :math:<code>x \\in \\{0,1\\}</code>. Else, :math:<code>x^2</code> is treated as a quadratic term. The default value is False.</p> <code>False</code> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>If there are Pauli Xs in any Pauli term</p> <code>QiskitOptimizationError</code> <p>If there are more than 2 Pauli Zs in any Pauli term</p> <code>NotImplementedError</code> <p>If the input operator is a ListOp</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def from_ising(\n    self,\n    qubit_op: BaseOperator,\n    offset: float = 0.0,\n    linear: bool = False,\n) -&gt; None:\n    r\"\"\"Create a quadratic program from a qubit operator and a shift value.\n\n    Variables are mapped to qubits in the same order, i.e.,\n    i-th variable is mapped to i-th qubit.\n    See https://github.com/Qiskit/qiskit-terra/issues/1148 for details.\n\n    Args:\n        qubit_op: The qubit operator of the problem.\n        offset: The constant value in the Ising Hamiltonian.\n        linear: If linear is True, :math:`x^2` is treated as a linear term\n            since :math:`x^2 = x` for :math:`x \\in \\{0,1\\}`.\n            Else, :math:`x^2` is treated as a quadratic term.\n            The default value is False.\n\n    Raises:\n        QiskitOptimizationError: If there are Pauli Xs in any Pauli term\n        QiskitOptimizationError: If there are more than 2 Pauli Zs in any Pauli term\n        NotImplementedError: If the input operator is a ListOp\n    \"\"\"\n    # pylint: disable=cyclic-import\n    from ..translators.ising import from_ising\n\n    other = from_ising(qubit_op, offset, linear)\n    self._copy_from(other, include_name=False)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.get_feasibility_info","title":"<code>get_feasibility_info(x)</code>","text":"<p>Returns whether a solution is feasible or not along with the violations. Args:     x: a solution value, such as returned in an optimizer result. Returns:     feasible: Whether the solution provided is feasible or not.     List[Variable]: List of variables which are violated.     List[Constraint]: List of constraints which are violated.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>If the input <code>x</code> is not same len as total vars</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def get_feasibility_info(\n    self, x: Union[List[float], np.ndarray]\n) -&gt; Tuple[bool, List[Variable], List[Constraint]]:\n    \"\"\"Returns whether a solution is feasible or not along with the violations.\n    Args:\n        x: a solution value, such as returned in an optimizer result.\n    Returns:\n        feasible: Whether the solution provided is feasible or not.\n        List[Variable]: List of variables which are violated.\n        List[Constraint]: List of constraints which are violated.\n\n    Raises:\n        QiskitOptimizationError: If the input `x` is not same len as total vars\n    \"\"\"\n    # if input `x` is not the same len as the total vars, raise an error\n    if len(x) != self.get_num_vars():\n        raise QiskitOptimizationError(\n            f\"The size of solution `x`: {len(x)}, does not match the number of problem variables: \"\n            f\"{self.get_num_vars()}\"\n        )\n\n    # check whether the input satisfy the bounds of the problem\n    violated_variables = []\n    for i, val in enumerate(x):\n        variable = self.get_variable(i)\n        if val &lt; variable.lowerbound or variable.upperbound &lt; val:\n            violated_variables.append(variable)\n\n    # check whether the input satisfy the constraints of the problem\n    violated_constraints = []\n    for constraint in cast(List[Constraint], self._linear_constraints) + cast(\n        List[Constraint], self._quadratic_constraints\n    ):\n        lhs = constraint.evaluate(x)\n        if constraint.sense == ConstraintSense.LE and lhs &gt; constraint.rhs:\n            violated_constraints.append(constraint)\n        elif constraint.sense == ConstraintSense.GE and lhs &lt; constraint.rhs:\n            violated_constraints.append(constraint)\n        elif constraint.sense == ConstraintSense.EQ and not isclose(\n            lhs, constraint.rhs\n        ):\n            violated_constraints.append(constraint)\n\n    feasible = not violated_variables and not violated_constraints\n\n    return feasible, violated_variables, violated_constraints\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.get_linear_constraint","title":"<code>get_linear_constraint(i)</code>","text":"<p>Returns a linear constraint for a given name or index.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>Union[int, str]</code> <p>the index or name of the constraint.</p> required <p>Returns:</p> Type Description <code>LinearConstraint</code> <p>The corresponding constraint.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>if the index is out of the list size</p> <code>KeyError</code> <p>if the name does not exist</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def get_linear_constraint(self, i: Union[int, str]) -&gt; LinearConstraint:\n    \"\"\"Returns a linear constraint for a given name or index.\n\n    Args:\n        i: the index or name of the constraint.\n\n    Returns:\n        The corresponding constraint.\n\n    Raises:\n        IndexError: if the index is out of the list size\n        KeyError: if the name does not exist\n    \"\"\"\n    if isinstance(i, int):\n        return self._linear_constraints[i]\n    else:\n        return self._linear_constraints[self._linear_constraints_index[i]]\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.get_num_binary_vars","title":"<code>get_num_binary_vars()</code>","text":"<p>Returns the total number of binary variables.</p> <p>Returns:</p> Type Description <code>int</code> <p>The total number of binary variables.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def get_num_binary_vars(self) -&gt; int:\n    \"\"\"Returns the total number of binary variables.\n\n    Returns:\n        The total number of binary variables.\n    \"\"\"\n    return self.get_num_vars(Variable.Type.BINARY)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.get_num_continuous_vars","title":"<code>get_num_continuous_vars()</code>","text":"<p>Returns the total number of continuous variables.</p> <p>Returns:</p> Type Description <code>int</code> <p>The total number of continuous variables.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def get_num_continuous_vars(self) -&gt; int:\n    \"\"\"Returns the total number of continuous variables.\n\n    Returns:\n        The total number of continuous variables.\n    \"\"\"\n    return self.get_num_vars(Variable.Type.CONTINUOUS)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.get_num_integer_vars","title":"<code>get_num_integer_vars()</code>","text":"<p>Returns the total number of integer variables.</p> <p>Returns:</p> Type Description <code>int</code> <p>The total number of integer variables.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def get_num_integer_vars(self) -&gt; int:\n    \"\"\"Returns the total number of integer variables.\n\n    Returns:\n        The total number of integer variables.\n    \"\"\"\n    return self.get_num_vars(Variable.Type.INTEGER)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.get_num_linear_constraints","title":"<code>get_num_linear_constraints()</code>","text":"<p>Returns the number of linear constraints.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of linear constraints.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def get_num_linear_constraints(self) -&gt; int:\n    \"\"\"Returns the number of linear constraints.\n\n    Returns:\n        The number of linear constraints.\n    \"\"\"\n    return len(self._linear_constraints)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.get_num_quadratic_constraints","title":"<code>get_num_quadratic_constraints()</code>","text":"<p>Returns the number of quadratic constraints.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of quadratic constraints.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def get_num_quadratic_constraints(self) -&gt; int:\n    \"\"\"Returns the number of quadratic constraints.\n\n    Returns:\n        The number of quadratic constraints.\n    \"\"\"\n    return len(self._quadratic_constraints)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.get_num_vars","title":"<code>get_num_vars(vartype=None)</code>","text":"<p>Returns the total number of variables or the number of variables of the specified type.</p> <p>Parameters:</p> Name Type Description Default <code>vartype</code> <code>Optional[VarType]</code> <p>The type to be filtered on. All variables are counted if None.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The total number of variables.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def get_num_vars(self, vartype: Optional[VarType] = None) -&gt; int:\n    \"\"\"Returns the total number of variables or the number of variables of the specified type.\n\n    Args:\n        vartype: The type to be filtered on. All variables are counted if None.\n\n    Returns:\n        The total number of variables.\n    \"\"\"\n    if vartype:\n        return sum(variable.vartype == vartype for variable in self._variables)\n    else:\n        return len(self._variables)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.get_quadratic_constraint","title":"<code>get_quadratic_constraint(i)</code>","text":"<p>Returns a quadratic constraint for a given name or index.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>Union[int, str]</code> <p>the index or name of the constraint.</p> required <p>Returns:</p> Type Description <code>QuadraticConstraint</code> <p>The corresponding constraint.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>if the index is out of the list size</p> <code>KeyError</code> <p>if the name does not exist</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def get_quadratic_constraint(self, i: Union[int, str]) -&gt; QuadraticConstraint:\n    \"\"\"Returns a quadratic constraint for a given name or index.\n\n    Args:\n        i: the index or name of the constraint.\n\n    Returns:\n        The corresponding constraint.\n\n    Raises:\n        IndexError: if the index is out of the list size\n        KeyError: if the name does not exist\n    \"\"\"\n    if isinstance(i, int):\n        return self._quadratic_constraints[i]\n    else:\n        return self._quadratic_constraints[self._quadratic_constraints_index[i]]\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.get_variable","title":"<code>get_variable(i)</code>","text":"<p>Returns a variable for a given name or index.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>Union[int, str]</code> <p>the index or name of the variable.</p> required <p>Returns:</p> Type Description <code>Variable</code> <p>The corresponding variable.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def get_variable(self, i: Union[int, str]) -&gt; Variable:\n    \"\"\"Returns a variable for a given name or index.\n\n    Args:\n        i: the index or name of the variable.\n\n    Returns:\n        The corresponding variable.\n    \"\"\"\n    if isinstance(i, (int, np.integer)):\n        return self.variables[i]\n    else:\n        return self.variables[self._variables_index[i]]\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.integer_var","title":"<code>integer_var(lowerbound=0, upperbound=INFINITY, name=None)</code>","text":"<p>Adds an integer variable to the quadratic program.</p> <p>Parameters:</p> Name Type Description Default <code>lowerbound</code> <code>Union[float, int]</code> <p>The lowerbound of the variable.</p> <code>0</code> <code>upperbound</code> <code>Union[float, int]</code> <p>The upperbound of the variable.</p> <code>INFINITY</code> <code>name</code> <code>Optional[str]</code> <p>The name of the variable. If it's <code>None</code> or empty <code>\"\"</code>, the default name, e.g., <code>x0</code>, is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The added variable.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if the variable name is already occupied.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def integer_var(\n    self,\n    lowerbound: Union[float, int] = 0,\n    upperbound: Union[float, int] = INFINITY,\n    name: Optional[str] = None,\n) -&gt; Variable:\n    \"\"\"Adds an integer variable to the quadratic program.\n\n    Args:\n        lowerbound: The lowerbound of the variable.\n        upperbound: The upperbound of the variable.\n        name: The name of the variable.\n            If it's ``None`` or empty ``\"\"``, the default name, e.g., ``x0``, is used.\n\n    Returns:\n        The added variable.\n\n    Raises:\n        QiskitOptimizationError: if the variable name is already occupied.\n    \"\"\"\n    return self._add_variable(lowerbound, upperbound, Variable.Type.INTEGER, name)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.integer_var_dict","title":"<code>integer_var_dict(keys, lowerbound=0, upperbound=INFINITY, name=None, key_format='{}')</code>","text":"<p>Uses 'var_dict' to construct a dictionary of integer variables</p> <p>Parameters:</p> Name Type Description Default <code>lowerbound</code> <code>Union[float, int]</code> <p>The lower bound of the variable(s).</p> <code>0</code> <code>upperbound</code> <code>Union[float, int]</code> <p>The upper bound of the variable(s).</p> <code>INFINITY</code> <code>name</code> <code>Optional[str]</code> <p>The name(s) of the variable(s). If it's <code>None</code> or empty <code>\"\"</code>, the default name, e.g., <code>x0</code>, is used.</p> <code>None</code> <code>key_format</code> <code>str</code> <p>The format used to name/index the variable(s).</p> <code>'{}'</code> <code>keys</code> <code>Union[int, Sequence]</code> <p>If keys: int, it is interpreted as the number of variables to construct.   Otherwise, the elements of the sequence are converted to strings via 'str' and   substituted into <code>key_format</code>.</p> required <p>Returns:</p> Type Description <code>Dict[str, Variable]</code> <p>A dictionary mapping the variable names to variable instances.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if the variable name is already taken.</p> <code>QiskitOptimizationError</code> <p>if less than one variable instantiation is attempted.</p> <code>QiskitOptimizationError</code> <p>if <code>key_format</code> has more than one substitution or a                      nested substitution.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def integer_var_dict(\n    self,\n    keys: Union[int, Sequence],\n    lowerbound: Union[float, int] = 0,\n    upperbound: Union[float, int] = INFINITY,\n    name: Optional[str] = None,\n    key_format: str = \"{}\",\n) -&gt; Dict[str, Variable]:\n    \"\"\"\n    Uses 'var_dict' to construct a dictionary of integer variables\n\n    Args:\n        lowerbound: The lower bound of the variable(s).\n        upperbound: The upper bound of the variable(s).\n        name: The name(s) of the variable(s).\n            If it's ``None`` or empty ``\"\"``, the default name, e.g., ``x0``, is used.\n        key_format: The format used to name/index the variable(s).\n        keys: If keys: int, it is interpreted as the number of variables to construct.\n              Otherwise, the elements of the sequence are converted to strings via 'str' and\n              substituted into `key_format`.\n\n    Returns:\n        A dictionary mapping the variable names to variable instances.\n\n    Raises:\n        QiskitOptimizationError: if the variable name is already taken.\n        QiskitOptimizationError: if less than one variable instantiation is attempted.\n        QiskitOptimizationError: if `key_format` has more than one substitution or a\n                                 nested substitution.\n    \"\"\"\n    return self._var_dict(\n        keys, lowerbound, upperbound, Variable.Type.INTEGER, name, key_format\n    )\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.integer_var_list","title":"<code>integer_var_list(keys, lowerbound=0, upperbound=INFINITY, name=None, key_format='{}')</code>","text":"<p>Uses 'var_list' to construct a list of integer variables</p> <p>Parameters:</p> Name Type Description Default <code>lowerbound</code> <code>Union[float, int]</code> <p>The lower bound of the variable(s).</p> <code>0</code> <code>upperbound</code> <code>Union[float, int]</code> <p>The upper bound of the variable(s).</p> <code>INFINITY</code> <code>name</code> <code>Optional[str]</code> <p>The name(s) of the variable(s). If it's <code>None</code> or empty <code>\"\"</code>, the default name, e.g., <code>x0</code>, is used.</p> <code>None</code> <code>key_format</code> <code>str</code> <p>The format used to name/index the variable(s).</p> <code>'{}'</code> <code>keys</code> <code>Union[int, Sequence]</code> <p>If keys: int, it is interpreted as the number of variables to construct.   Otherwise, the elements of the sequence are converted to strings via 'str' and   substituted into <code>key_format</code>.</p> required <p>Returns:</p> Type Description <code>List[Variable]</code> <p>A list of variable instances.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if the variable name is already taken.</p> <code>QiskitOptimizationError</code> <p>if less than one variable instantiation is attempted.</p> <code>QiskitOptimizationError</code> <p>if <code>key_format</code> has more than one substitution or a                      nested substitution.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def integer_var_list(\n    self,\n    keys: Union[int, Sequence],\n    lowerbound: Union[float, int] = 0,\n    upperbound: Union[float, int] = INFINITY,\n    name: Optional[str] = None,\n    key_format: str = \"{}\",\n) -&gt; List[Variable]:\n    \"\"\"\n    Uses 'var_list' to construct a list of integer variables\n\n    Args:\n        lowerbound: The lower bound of the variable(s).\n        upperbound: The upper bound of the variable(s).\n        name: The name(s) of the variable(s).\n            If it's ``None`` or empty ``\"\"``, the default name, e.g., ``x0``, is used.\n        key_format: The format used to name/index the variable(s).\n        keys: If keys: int, it is interpreted as the number of variables to construct.\n              Otherwise, the elements of the sequence are converted to strings via 'str' and\n              substituted into `key_format`.\n\n    Returns:\n        A list of variable instances.\n\n    Raises:\n        QiskitOptimizationError: if the variable name is already taken.\n        QiskitOptimizationError: if less than one variable instantiation is attempted.\n        QiskitOptimizationError: if `key_format` has more than one substitution or a\n                                 nested substitution.\n    \"\"\"\n    return self._var_list(\n        keys, lowerbound, upperbound, Variable.Type.INTEGER, name, key_format\n    )\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.is_feasible","title":"<code>is_feasible(x)</code>","text":"<p>Returns whether a solution is feasible or not.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[List[float], ndarray]</code> <p>a solution value, such as returned in an optimizer result.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the solution provided is feasible otherwise <code>False</code>.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def is_feasible(self, x: Union[List[float], np.ndarray]) -&gt; bool:\n    \"\"\"Returns whether a solution is feasible or not.\n\n    Args:\n        x: a solution value, such as returned in an optimizer result.\n\n    Returns:\n        ``True`` if the solution provided is feasible otherwise ``False``.\n\n    \"\"\"\n    feasible, _, _ = self.get_feasibility_info(x)\n\n    return feasible\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.linear_constraint","title":"<code>linear_constraint(linear=None, sense='&lt;=', rhs=0.0, name=None)</code>","text":"Adds a linear equality constraint to the quadratic program of the form <p><code>(linear * x) sense rhs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>linear</code> <code>Union[ndarray, spmatrix, List[float], Dict[Union[int, str], float]]</code> <p>The linear coefficients of the left-hand side of the constraint.</p> <code>None</code> <code>sense</code> <code>Union[str, ConstraintSense]</code> <p>The sense of the constraint,</p> <ul> <li><code>==</code>, <code>=</code>, <code>E</code>, and <code>EQ</code> denote 'equal to'.</li> <li><code>&gt;=</code>, <code>&gt;</code>, <code>G</code>, and <code>GE</code> denote 'greater-than-or-equal-to'.</li> <li><code>&lt;=</code>, <code>&lt;</code>, <code>L</code>, and <code>LE</code> denote 'less-than-or-equal-to'.</li> </ul> <code>'&lt;='</code> <code>rhs</code> <code>float</code> <p>The right-hand side of the constraint.</p> <code>0.0</code> <code>name</code> <code>Optional[str]</code> <p>The name of the constraint. If it's <code>None</code> or empty <code>\"\"</code>, the default name, e.g., <code>c0</code>, is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>LinearConstraint</code> <p>The added constraint.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if the constraint name already exists or the sense is not valid.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def linear_constraint(\n    self,\n    linear: Union[\n        ndarray, spmatrix, List[float], Dict[Union[int, str], float]\n    ] = None,\n    sense: Union[str, ConstraintSense] = \"&lt;=\",\n    rhs: float = 0.0,\n    name: Optional[str] = None,\n) -&gt; LinearConstraint:\n    \"\"\"Adds a linear equality constraint to the quadratic program of the form:\n        ``(linear * x) sense rhs``.\n\n    Args:\n        linear: The linear coefficients of the left-hand side of the constraint.\n        sense: The sense of the constraint,\n\n            - ``==``, ``=``, ``E``, and ``EQ`` denote 'equal to'.\n            - ``&gt;=``, ``&gt;``, ``G``, and ``GE`` denote 'greater-than-or-equal-to'.\n            - ``&lt;=``, ``&lt;``, ``L``, and ``LE`` denote 'less-than-or-equal-to'.\n\n        rhs: The right-hand side of the constraint.\n        name: The name of the constraint.\n            If it's ``None`` or empty ``\"\"``, the default name, e.g., ``c0``, is used.\n\n    Returns:\n        The added constraint.\n\n    Raises:\n        QiskitOptimizationError: if the constraint name already exists or the sense is not\n            valid.\n    \"\"\"\n    if name:\n        if name in self.linear_constraints_index:\n            raise QiskitOptimizationError(\n                f\"Linear constraint's name already exists: {name}\"\n            )\n        self._check_name(name, \"Linear constraint\")\n    else:\n        k = self.get_num_linear_constraints()\n        while f\"c{k}\" in self.linear_constraints_index:\n            k += 1\n        name = f\"c{k}\"\n    self.linear_constraints_index[name] = len(self.linear_constraints)\n    if linear is None:\n        linear = {}\n    constraint = LinearConstraint(\n        self, name, linear, Constraint.Sense.convert(sense), rhs\n    )\n    self.linear_constraints.append(constraint)\n    return constraint\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.maximize","title":"<code>maximize(constant=0.0, linear=None, quadratic=None)</code>","text":"<p>Sets a quadratic objective to be maximized.</p> <p>Parameters:</p> Name Type Description Default <code>constant</code> <code>float</code> <p>the constant offset of the objective.</p> <code>0.0</code> <code>linear</code> <code>Union[ndarray, spmatrix, List[float], Dict[Union[str, int], float]]</code> <p>the coefficients of the linear part of the objective.</p> <code>None</code> <code>quadratic</code> <code>Union[ndarray, spmatrix, List[List[float]], Dict[Tuple[Union[int, str], Union[int, str]], float]]</code> <p>the coefficients of the quadratic part of the objective.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>The created quadratic objective.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def maximize(\n    self,\n    constant: float = 0.0,\n    linear: Union[\n        ndarray, spmatrix, List[float], Dict[Union[str, int], float]\n    ] = None,\n    quadratic: Union[\n        ndarray,\n        spmatrix,\n        List[List[float]],\n        Dict[Tuple[Union[int, str], Union[int, str]], float],\n    ] = None,\n) -&gt; None:\n    \"\"\"Sets a quadratic objective to be maximized.\n\n    Args:\n        constant: the constant offset of the objective.\n        linear: the coefficients of the linear part of the objective.\n        quadratic: the coefficients of the quadratic part of the objective.\n\n    Returns:\n        The created quadratic objective.\n    \"\"\"\n    self._objective = QuadraticObjective(\n        self, constant, linear, quadratic, QuadraticObjective.Sense.MAXIMIZE\n    )\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.minimize","title":"<code>minimize(constant=0.0, linear=None, quadratic=None)</code>","text":"<p>Sets a quadratic objective to be minimized.</p> <p>Parameters:</p> Name Type Description Default <code>constant</code> <code>float</code> <p>the constant offset of the objective.</p> <code>0.0</code> <code>linear</code> <code>Union[ndarray, spmatrix, List[float], Dict[Union[str, int], float]]</code> <p>the coefficients of the linear part of the objective.</p> <code>None</code> <code>quadratic</code> <code>Union[ndarray, spmatrix, List[List[float]], Dict[Tuple[Union[int, str], Union[int, str]], float]]</code> <p>the coefficients of the quadratic part of the objective.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>The created quadratic objective.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def minimize(\n    self,\n    constant: float = 0.0,\n    linear: Union[\n        ndarray, spmatrix, List[float], Dict[Union[str, int], float]\n    ] = None,\n    quadratic: Union[\n        ndarray,\n        spmatrix,\n        List[List[float]],\n        Dict[Tuple[Union[int, str], Union[int, str]], float],\n    ] = None,\n) -&gt; None:\n    \"\"\"Sets a quadratic objective to be minimized.\n\n    Args:\n        constant: the constant offset of the objective.\n        linear: the coefficients of the linear part of the objective.\n        quadratic: the coefficients of the quadratic part of the objective.\n\n    Returns:\n        The created quadratic objective.\n    \"\"\"\n    self._objective = QuadraticObjective(\n        self, constant, linear, quadratic, QuadraticObjective.Sense.MINIMIZE\n    )\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.prettyprint","title":"<code>prettyprint(wrap=80)</code>","text":"<p>Returns a pretty printed string of this problem.</p> <p>Parameters:</p> Name Type Description Default <code>wrap</code> <code>int</code> <p>The text width to wrap the output strings. It is disabled by setting 0. Note that some strings might exceed this value, for example, a long variable name won't be wrapped. The default value is 80.</p> <code>80</code> <p>Returns:</p> Type Description <code>str</code> <p>A pretty printed string representing the problem.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if there is a non-printable name.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def prettyprint(self, wrap: int = 80) -&gt; str:\n    \"\"\"Returns a pretty printed string of this problem.\n\n    Args:\n        wrap: The text width to wrap the output strings. It is disabled by setting 0.\n            Note that some strings might exceed this value, for example, a long variable\n            name won't be wrapped. The default value is 80.\n\n    Returns:\n        A pretty printed string representing the problem.\n\n    Raises:\n        QiskitOptimizationError: if there is a non-printable name.\n    \"\"\"\n    # pylint: disable=cyclic-import\n    from ..translators.prettyprint import prettyprint\n\n    return prettyprint(self, wrap)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.quadratic_constraint","title":"<code>quadratic_constraint(linear=None, quadratic=None, sense='&lt;=', rhs=0.0, name=None)</code>","text":"Adds a quadratic equality constraint to the quadratic program of the form <p><code>(x * quadratic * x + linear * x) sense rhs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>linear</code> <code>Union[ndarray, spmatrix, List[float], Dict[Union[int, str], float]]</code> <p>The linear coefficients of the constraint.</p> <code>None</code> <code>quadratic</code> <code>Union[ndarray, spmatrix, List[List[float]], Dict[Tuple[Union[int, str], Union[int, str]], float]]</code> <p>The quadratic coefficients of the constraint.</p> <code>None</code> <code>sense</code> <code>Union[str, ConstraintSense]</code> <p>The sense of the constraint,</p> <ul> <li><code>==</code>, <code>=</code>, <code>E</code>, and <code>EQ</code> denote 'equal to'.</li> <li><code>&gt;=</code>, <code>&gt;</code>, <code>G</code>, and <code>GE</code> denote 'greater-than-or-equal-to'.</li> <li><code>&lt;=</code>, <code>&lt;</code>, <code>L</code>, and <code>LE</code> denote 'less-than-or-equal-to'.</li> </ul> <code>'&lt;='</code> <code>rhs</code> <code>float</code> <p>The right-hand side of the constraint.</p> <code>0.0</code> <code>name</code> <code>Optional[str]</code> <p>The name of the constraint. If it's <code>None</code> or empty <code>\"\"</code>, the default name, e.g., <code>q0</code>, is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>QuadraticConstraint</code> <p>The added constraint.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if the constraint name already exists.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def quadratic_constraint(\n    self,\n    linear: Union[\n        ndarray, spmatrix, List[float], Dict[Union[int, str], float]\n    ] = None,\n    quadratic: Union[\n        ndarray,\n        spmatrix,\n        List[List[float]],\n        Dict[Tuple[Union[int, str], Union[int, str]], float],\n    ] = None,\n    sense: Union[str, ConstraintSense] = \"&lt;=\",\n    rhs: float = 0.0,\n    name: Optional[str] = None,\n) -&gt; QuadraticConstraint:\n    \"\"\"Adds a quadratic equality constraint to the quadratic program of the form:\n        ``(x * quadratic * x + linear * x) sense rhs``.\n\n    Args:\n        linear: The linear coefficients of the constraint.\n        quadratic: The quadratic coefficients of the constraint.\n        sense: The sense of the constraint,\n\n            - ``==``, ``=``, ``E``, and ``EQ`` denote 'equal to'.\n            - ``&gt;=``, ``&gt;``, ``G``, and ``GE`` denote 'greater-than-or-equal-to'.\n            - ``&lt;=``, ``&lt;``, ``L``, and ``LE`` denote 'less-than-or-equal-to'.\n\n        rhs: The right-hand side of the constraint.\n        name: The name of the constraint.\n            If it's ``None`` or empty ``\"\"``, the default name, e.g., ``q0``, is used.\n\n    Returns:\n        The added constraint.\n\n    Raises:\n        QiskitOptimizationError: if the constraint name already exists.\n    \"\"\"\n    if name:\n        if name in self.quadratic_constraints_index:\n            raise QiskitOptimizationError(\n                f\"Quadratic constraint name already exists: {name}\"\n            )\n        self._check_name(name, \"Quadratic constraint\")\n    else:\n        k = self.get_num_quadratic_constraints()\n        while f\"q{k}\" in self.quadratic_constraints_index:\n            k += 1\n        name = f\"q{k}\"\n    self.quadratic_constraints_index[name] = len(self.quadratic_constraints)\n    if linear is None:\n        linear = {}\n    if quadratic is None:\n        quadratic = {}\n    constraint = QuadraticConstraint(\n        self, name, linear, quadratic, Constraint.Sense.convert(sense), rhs\n    )\n    self.quadratic_constraints.append(constraint)\n    return constraint\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.remove_linear_constraint","title":"<code>remove_linear_constraint(i)</code>","text":"<p>Remove a linear constraint</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>Union[str, int]</code> <p>an index or a name of a linear constraint</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>if name does not exist</p> <code>IndexError</code> <p>if index is out of range</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def remove_linear_constraint(self, i: Union[str, int]) -&gt; None:\n    \"\"\"Remove a linear constraint\n\n    Args:\n        i: an index or a name of a linear constraint\n\n    Raises:\n        KeyError: if name does not exist\n        IndexError: if index is out of range\n    \"\"\"\n    if isinstance(i, str):\n        i = self._linear_constraints_index[i]\n    del self._linear_constraints[i]\n    self._linear_constraints_index = {\n        cst.name: j for j, cst in enumerate(self._linear_constraints)\n    }\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.remove_quadratic_constraint","title":"<code>remove_quadratic_constraint(i)</code>","text":"<p>Remove a quadratic constraint</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>Union[str, int]</code> <p>an index or a name of a quadratic constraint</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>if name does not exist</p> <code>IndexError</code> <p>if index is out of range</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def remove_quadratic_constraint(self, i: Union[str, int]) -&gt; None:\n    \"\"\"Remove a quadratic constraint\n\n    Args:\n        i: an index or a name of a quadratic constraint\n\n    Raises:\n        KeyError: if name does not exist\n        IndexError: if index is out of range\n    \"\"\"\n    if isinstance(i, str):\n        i = self._quadratic_constraints_index[i]\n    del self._quadratic_constraints[i]\n    self._quadratic_constraints_index = {\n        cst.name: j for j, cst in enumerate(self._quadratic_constraints)\n    }\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.substitute_variables","title":"<code>substitute_variables(constants=None, variables=None)</code>","text":"<p>Substitutes variables with constants or other variables.</p> <p>Parameters:</p> Name Type Description Default <code>constants</code> <code>Optional[Dict[Union[str, int], float]]</code> <p>replace variable by constant e.g., <code>{'x': 2}</code> means <code>x</code> is substituted with 2</p> <code>None</code> <code>variables</code> <code>Optional[Dict[Union[str, int], Tuple[Union[str, int], float]]]</code> <p>replace variables by weighted other variable need to copy everything using name reference to make sure that indices are matched correctly. The lower and upper bounds are updated accordingly. e.g., <code>{'x': ('y', 2)}</code> means <code>x</code> is substituted with <code>y * 2</code></p> <code>None</code> <p>Returns:</p> Type Description <code>QuadraticProgram</code> <p>An optimization problem by substituting variables with constants or other variables.</p> <code>QuadraticProgram</code> <p>If the substitution is valid, <code>QuadraticProgram.status</code> is still</p> <code>QuadraticProgram</code> <p><code>QuadraticProgram.Status.VALID</code>.</p> <code>QuadraticProgram</code> <p>Otherwise, it gets <code>QuadraticProgram.Status.INFEASIBLE</code>.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if the substitution is invalid as follows.</p> <ul> <li>Same variable is substituted multiple times.</li> <li>Coefficient of variable substitution is zero.</li> </ul> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def substitute_variables(\n    self,\n    constants: Optional[Dict[Union[str, int], float]] = None,\n    variables: Optional[\n        Dict[Union[str, int], Tuple[Union[str, int], float]]\n    ] = None,\n) -&gt; \"QuadraticProgram\":\n    \"\"\"Substitutes variables with constants or other variables.\n\n    Args:\n        constants: replace variable by constant\n            e.g., ``{'x': 2}`` means ``x`` is substituted with 2\n\n        variables: replace variables by weighted other variable\n            need to copy everything using name reference to make sure that indices are matched\n            correctly. The lower and upper bounds are updated accordingly.\n            e.g., ``{'x': ('y', 2)}`` means ``x`` is substituted with ``y * 2``\n\n    Returns:\n        An optimization problem by substituting variables with constants or other variables.\n        If the substitution is valid, ``QuadraticProgram.status`` is still\n        ``QuadraticProgram.Status.VALID``.\n        Otherwise, it gets ``QuadraticProgram.Status.INFEASIBLE``.\n\n    Raises:\n        QiskitOptimizationError: if the substitution is invalid as follows.\n\n            - Same variable is substituted multiple times.\n            - Coefficient of variable substitution is zero.\n    \"\"\"\n    # pylint: disable=cyclic-import\n    from .substitute_variables import substitute_variables\n\n    return substitute_variables(self, constants, variables)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgram/#q3as.quadratic.QuadraticProgram.to_ising","title":"<code>to_ising()</code>","text":"<p>Return the Ising Hamiltonian of this problem.</p> <p>Variables are mapped to qubits in the same order, i.e., i-th variable is mapped to i-th qubit. See https://github.com/Qiskit/qiskit-terra/issues/1148 for details.</p> <p>Returns:</p> Name Type Description <code>qubit_op</code> <code>SparsePauliOp</code> <p>The qubit operator for the problem</p> <code>offset</code> <code>float</code> <p>The constant value in the Ising Hamiltonian.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>If a variable type is not binary.</p> <code>QiskitOptimizationError</code> <p>If constraints exist in the problem.</p> Source code in <code>q3as/quadratic/problems/quadratic_program.py</code> <pre><code>def to_ising(self) -&gt; Tuple[SparsePauliOp, float]:\n    \"\"\"Return the Ising Hamiltonian of this problem.\n\n    Variables are mapped to qubits in the same order, i.e.,\n    i-th variable is mapped to i-th qubit.\n    See https://github.com/Qiskit/qiskit-terra/issues/1148 for details.\n\n    Returns:\n        qubit_op: The qubit operator for the problem\n        offset: The constant value in the Ising Hamiltonian.\n\n    Raises:\n        QiskitOptimizationError: If a variable type is not binary.\n        QiskitOptimizationError: If constraints exist in the problem.\n    \"\"\"\n    # pylint: disable=cyclic-import\n    from ..translators.ising import to_ising\n\n    return to_ising(self)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgramElement/","title":"QuadraticProgramElement","text":"<p>Interface class for all objects that have a parent QuadraticProgram.</p> Source code in <code>q3as/quadratic/problems/quadratic_program_element.py</code> <pre><code>class QuadraticProgramElement:\n    \"\"\"Interface class for all objects that have a parent QuadraticProgram.\"\"\"\n\n    def __init__(self, quadratic_program: \"problems.QuadraticProgram\") -&gt; None:\n        \"\"\"Initialize object with parent QuadraticProgram.\n\n        Args:\n            quadratic_program: The parent QuadraticProgram.\n        Raises:\n            TypeError: QuadraticProgram instance expected.\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from .quadratic_program import QuadraticProgram\n\n        if not isinstance(quadratic_program, QuadraticProgram):\n            raise TypeError(\"QuadraticProgram instance expected\")\n\n        self._quadratic_program = quadratic_program\n\n    @property\n    def quadratic_program(self) -&gt; \"problems.QuadraticProgram\":\n        \"\"\"Returns the parent QuadraticProgram.\n\n        Returns:\n            The parent QuadraticProgram.\n        \"\"\"\n        return self._quadratic_program\n\n    @quadratic_program.setter\n    def quadratic_program(self, quadratic_program: \"problems.QuadraticProgram\") -&gt; None:\n        \"\"\"Sets the parent QuadraticProgram.\n\n        Args:\n            quadratic_program: The parent QuadraticProgram.\n        Raises:\n            TypeError: QuadraticProgram instance expected.\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from .quadratic_program import QuadraticProgram\n\n        if not isinstance(quadratic_program, QuadraticProgram):\n            raise TypeError(\"QuadraticProgram instance expected\")\n\n        self._quadratic_program = quadratic_program\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgramElement/#q3as.quadratic.QuadraticProgramElement.quadratic_program","title":"<code>quadratic_program: problems.QuadraticProgram</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the parent QuadraticProgram.</p> <p>Returns:</p> Type Description <code>QuadraticProgram</code> <p>The parent QuadraticProgram.</p>"},{"location":"reference/q3as.quadratic/QuadraticProgramElement/#q3as.quadratic.QuadraticProgramElement.__init__","title":"<code>__init__(quadratic_program)</code>","text":"<p>Initialize object with parent QuadraticProgram.</p> <p>Parameters:</p> Name Type Description Default <code>quadratic_program</code> <code>QuadraticProgram</code> <p>The parent QuadraticProgram.</p> required <p>Raises:     TypeError: QuadraticProgram instance expected.</p> Source code in <code>q3as/quadratic/problems/quadratic_program_element.py</code> <pre><code>def __init__(self, quadratic_program: \"problems.QuadraticProgram\") -&gt; None:\n    \"\"\"Initialize object with parent QuadraticProgram.\n\n    Args:\n        quadratic_program: The parent QuadraticProgram.\n    Raises:\n        TypeError: QuadraticProgram instance expected.\n    \"\"\"\n    # pylint: disable=cyclic-import\n    from .quadratic_program import QuadraticProgram\n\n    if not isinstance(quadratic_program, QuadraticProgram):\n        raise TypeError(\"QuadraticProgram instance expected\")\n\n    self._quadratic_program = quadratic_program\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgramStatus/","title":"QuadraticProgramStatus","text":"<p>               Bases: <code>Enum</code></p> <p>Status of QuadraticProgram</p> Source code in <code>q3as/quadratic/problems/types.py</code> <pre><code>class QuadraticProgramStatus(Enum):\n    \"\"\"Status of QuadraticProgram\"\"\"\n\n    VALID = 0\n    INFEASIBLE = 1\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgramToQubo/","title":"QuadraticProgramToQubo","text":"<p>               Bases: <code>QuadraticProgramConverter</code></p> <p>Convert a given optimization problem to a new problem that is a QUBO.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from qiskit_optimization.problems import QuadraticProgram\n&gt;&gt;&gt; from qiskit_optimization.converters import QuadraticProgramToQubo\n&gt;&gt;&gt; problem = QuadraticProgram()\n&gt;&gt;&gt; # define a problem\n&gt;&gt;&gt; conv = QuadraticProgramToQubo()\n&gt;&gt;&gt; problem2 = conv.convert(problem)\n</code></pre> Source code in <code>q3as/quadratic/converters/quadratic_program_to_qubo.py</code> <pre><code>class QuadraticProgramToQubo(QuadraticProgramConverter):\n    \"\"\"Convert a given optimization problem to a new problem that is a QUBO.\n\n    Examples:\n        &gt;&gt;&gt; from qiskit_optimization.problems import QuadraticProgram\n        &gt;&gt;&gt; from qiskit_optimization.converters import QuadraticProgramToQubo\n        &gt;&gt;&gt; problem = QuadraticProgram()\n        &gt;&gt;&gt; # define a problem\n        &gt;&gt;&gt; conv = QuadraticProgramToQubo()\n        &gt;&gt;&gt; problem2 = conv.convert(problem)\n    \"\"\"\n\n    def __init__(self, penalty: Optional[float] = None) -&gt; None:\n        \"\"\"\n        Args:\n            penalty: Penalty factor to scale equality constraints that are added to objective.\n                If None is passed, a penalty factor will be automatically calculated on every\n                conversion.\n        \"\"\"\n        self._penalize_lin_eq_constraints = LinearEqualityToPenalty(penalty=penalty)\n        self._penalize_lin_ineq_constraints = LinearInequalityToPenalty(penalty=penalty)\n        self._converters = [\n            self._penalize_lin_ineq_constraints,\n            InequalityToEquality(mode=\"integer\"),\n            IntegerToBinary(),\n            self._penalize_lin_eq_constraints,\n            MaximizeToMinimize(),\n        ]\n\n    def convert(self, problem: QuadraticProgram) -&gt; QuadraticProgram:\n        \"\"\"Convert a problem with linear constraints into new one with a QUBO form.\n\n        Args:\n            problem: The problem with linear constraints to be solved.\n\n        Returns:\n            The problem converted in QUBO format as minimization problem.\n\n        Raises:\n            QiskitOptimizationError: In case of an incompatible problem.\n        \"\"\"\n\n        # analyze compatibility of problem\n        msg = self.get_compatibility_msg(problem)\n        if len(msg) &gt; 0:\n            raise QiskitOptimizationError(f\"Incompatible problem: {msg}\")\n\n        for conv in self._converters:\n            problem = conv.convert(problem)\n        return problem\n\n    def interpret(self, x: Union[np.ndarray, List[float]]) -&gt; np.ndarray:\n        \"\"\"Convert a result of a converted problem into that of the original problem.\n\n        Args:\n            x: The result of the converted problem.\n\n        Returns:\n            The result of the original problem.\n        \"\"\"\n        for conv in self._converters[::-1]:\n            x = conv.interpret(x)\n        return cast(np.ndarray, x)\n\n    @staticmethod\n    def get_compatibility_msg(problem: QuadraticProgram) -&gt; str:\n        \"\"\"Checks whether a given problem can be solved with this optimizer.\n\n        Checks whether the given problem is compatible, i.e., whether the problem can be converted\n        to a QUBO, and otherwise, returns a message explaining the incompatibility.\n\n        Args:\n            problem: The optimization problem to check compatibility.\n\n        Returns:\n            A message describing the incompatibility.\n        \"\"\"\n\n        # initialize message\n        msg = \"\"\n        # check whether there are incompatible variable types\n        if problem.get_num_continuous_vars() &gt; 0:\n            msg += \"Continuous variables are not supported! \"\n\n        # check whether there are incompatible constraint types\n        if len(problem.quadratic_constraints) &gt; 0:\n            msg += \"Quadratic constraints are not supported. \"\n        # check whether there are float coefficients in constraints\n        compatible_with_integer_slack = True\n        for l_constraint in problem.linear_constraints:\n            linear = l_constraint.linear.to_dict()\n            if any(\n                isinstance(coef, float) and not coef.is_integer()\n                for coef in linear.values()\n            ):\n                compatible_with_integer_slack = False\n        for q_constraint in problem.quadratic_constraints:\n            linear = q_constraint.linear.to_dict()\n            quadratic = q_constraint.quadratic.to_dict()\n            if any(\n                isinstance(coef, float) and not coef.is_integer()\n                for coef in quadratic.values()\n            ) or any(\n                isinstance(coef, float) and not coef.is_integer()\n                for coef in linear.values()\n            ):\n                compatible_with_integer_slack = False\n        if not compatible_with_integer_slack:\n            msg += (\n                \"Can not convert inequality constraints to equality constraint because \\\n                    float coefficients are in constraints. \"\n            )\n\n        # if an error occurred, return error message, otherwise, return the empty string\n        return msg\n\n    def is_compatible(self, problem: QuadraticProgram) -&gt; bool:\n        \"\"\"Checks whether a given problem can be solved with the optimizer implementing this method.\n\n        Args:\n            problem: The optimization problem to check compatibility.\n\n        Returns:\n            Returns True if the problem is compatible, False otherwise.\n        \"\"\"\n        return len(self.get_compatibility_msg(problem)) == 0\n\n    @property\n    def penalty(self) -&gt; Optional[float]:\n        \"\"\"Returns the penalty factor used in conversion.\n\n        Returns:\n            The penalty factor used in conversion.\n        \"\"\"\n        return self._penalize_lin_eq_constraints.penalty\n\n    @penalty.setter\n    def penalty(self, penalty: Optional[float]) -&gt; None:\n        \"\"\"Set a new penalty factor.\n\n        Args:\n            penalty: The new penalty factor.\n                     If None is passed, a penalty factor will be automatically calculated on every\n                     conversion.\n        \"\"\"\n        self._penalize_lin_ineq_constraints.penalty = penalty\n        self._penalize_lin_eq_constraints.penalty = penalty\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgramToQubo/#q3as.quadratic.QuadraticProgramToQubo.penalty","title":"<code>penalty: Optional[float]</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the penalty factor used in conversion.</p> <p>Returns:</p> Type Description <code>Optional[float]</code> <p>The penalty factor used in conversion.</p>"},{"location":"reference/q3as.quadratic/QuadraticProgramToQubo/#q3as.quadratic.QuadraticProgramToQubo.__init__","title":"<code>__init__(penalty=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>penalty</code> <code>Optional[float]</code> <p>Penalty factor to scale equality constraints that are added to objective. If None is passed, a penalty factor will be automatically calculated on every conversion.</p> <code>None</code> Source code in <code>q3as/quadratic/converters/quadratic_program_to_qubo.py</code> <pre><code>def __init__(self, penalty: Optional[float] = None) -&gt; None:\n    \"\"\"\n    Args:\n        penalty: Penalty factor to scale equality constraints that are added to objective.\n            If None is passed, a penalty factor will be automatically calculated on every\n            conversion.\n    \"\"\"\n    self._penalize_lin_eq_constraints = LinearEqualityToPenalty(penalty=penalty)\n    self._penalize_lin_ineq_constraints = LinearInequalityToPenalty(penalty=penalty)\n    self._converters = [\n        self._penalize_lin_ineq_constraints,\n        InequalityToEquality(mode=\"integer\"),\n        IntegerToBinary(),\n        self._penalize_lin_eq_constraints,\n        MaximizeToMinimize(),\n    ]\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgramToQubo/#q3as.quadratic.QuadraticProgramToQubo.convert","title":"<code>convert(problem)</code>","text":"<p>Convert a problem with linear constraints into new one with a QUBO form.</p> <p>Parameters:</p> Name Type Description Default <code>problem</code> <code>QuadraticProgram</code> <p>The problem with linear constraints to be solved.</p> required <p>Returns:</p> Type Description <code>QuadraticProgram</code> <p>The problem converted in QUBO format as minimization problem.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>In case of an incompatible problem.</p> Source code in <code>q3as/quadratic/converters/quadratic_program_to_qubo.py</code> <pre><code>def convert(self, problem: QuadraticProgram) -&gt; QuadraticProgram:\n    \"\"\"Convert a problem with linear constraints into new one with a QUBO form.\n\n    Args:\n        problem: The problem with linear constraints to be solved.\n\n    Returns:\n        The problem converted in QUBO format as minimization problem.\n\n    Raises:\n        QiskitOptimizationError: In case of an incompatible problem.\n    \"\"\"\n\n    # analyze compatibility of problem\n    msg = self.get_compatibility_msg(problem)\n    if len(msg) &gt; 0:\n        raise QiskitOptimizationError(f\"Incompatible problem: {msg}\")\n\n    for conv in self._converters:\n        problem = conv.convert(problem)\n    return problem\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgramToQubo/#q3as.quadratic.QuadraticProgramToQubo.get_compatibility_msg","title":"<code>get_compatibility_msg(problem)</code>  <code>staticmethod</code>","text":"<p>Checks whether a given problem can be solved with this optimizer.</p> <p>Checks whether the given problem is compatible, i.e., whether the problem can be converted to a QUBO, and otherwise, returns a message explaining the incompatibility.</p> <p>Parameters:</p> Name Type Description Default <code>problem</code> <code>QuadraticProgram</code> <p>The optimization problem to check compatibility.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A message describing the incompatibility.</p> Source code in <code>q3as/quadratic/converters/quadratic_program_to_qubo.py</code> <pre><code>@staticmethod\ndef get_compatibility_msg(problem: QuadraticProgram) -&gt; str:\n    \"\"\"Checks whether a given problem can be solved with this optimizer.\n\n    Checks whether the given problem is compatible, i.e., whether the problem can be converted\n    to a QUBO, and otherwise, returns a message explaining the incompatibility.\n\n    Args:\n        problem: The optimization problem to check compatibility.\n\n    Returns:\n        A message describing the incompatibility.\n    \"\"\"\n\n    # initialize message\n    msg = \"\"\n    # check whether there are incompatible variable types\n    if problem.get_num_continuous_vars() &gt; 0:\n        msg += \"Continuous variables are not supported! \"\n\n    # check whether there are incompatible constraint types\n    if len(problem.quadratic_constraints) &gt; 0:\n        msg += \"Quadratic constraints are not supported. \"\n    # check whether there are float coefficients in constraints\n    compatible_with_integer_slack = True\n    for l_constraint in problem.linear_constraints:\n        linear = l_constraint.linear.to_dict()\n        if any(\n            isinstance(coef, float) and not coef.is_integer()\n            for coef in linear.values()\n        ):\n            compatible_with_integer_slack = False\n    for q_constraint in problem.quadratic_constraints:\n        linear = q_constraint.linear.to_dict()\n        quadratic = q_constraint.quadratic.to_dict()\n        if any(\n            isinstance(coef, float) and not coef.is_integer()\n            for coef in quadratic.values()\n        ) or any(\n            isinstance(coef, float) and not coef.is_integer()\n            for coef in linear.values()\n        ):\n            compatible_with_integer_slack = False\n    if not compatible_with_integer_slack:\n        msg += (\n            \"Can not convert inequality constraints to equality constraint because \\\n                float coefficients are in constraints. \"\n        )\n\n    # if an error occurred, return error message, otherwise, return the empty string\n    return msg\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgramToQubo/#q3as.quadratic.QuadraticProgramToQubo.interpret","title":"<code>interpret(x)</code>","text":"<p>Convert a result of a converted problem into that of the original problem.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ndarray, List[float]]</code> <p>The result of the converted problem.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The result of the original problem.</p> Source code in <code>q3as/quadratic/converters/quadratic_program_to_qubo.py</code> <pre><code>def interpret(self, x: Union[np.ndarray, List[float]]) -&gt; np.ndarray:\n    \"\"\"Convert a result of a converted problem into that of the original problem.\n\n    Args:\n        x: The result of the converted problem.\n\n    Returns:\n        The result of the original problem.\n    \"\"\"\n    for conv in self._converters[::-1]:\n        x = conv.interpret(x)\n    return cast(np.ndarray, x)\n</code></pre>"},{"location":"reference/q3as.quadratic/QuadraticProgramToQubo/#q3as.quadratic.QuadraticProgramToQubo.is_compatible","title":"<code>is_compatible(problem)</code>","text":"<p>Checks whether a given problem can be solved with the optimizer implementing this method.</p> <p>Parameters:</p> Name Type Description Default <code>problem</code> <code>QuadraticProgram</code> <p>The optimization problem to check compatibility.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Returns True if the problem is compatible, False otherwise.</p> Source code in <code>q3as/quadratic/converters/quadratic_program_to_qubo.py</code> <pre><code>def is_compatible(self, problem: QuadraticProgram) -&gt; bool:\n    \"\"\"Checks whether a given problem can be solved with the optimizer implementing this method.\n\n    Args:\n        problem: The optimization problem to check compatibility.\n\n    Returns:\n        Returns True if the problem is compatible, False otherwise.\n    \"\"\"\n    return len(self.get_compatibility_msg(problem)) == 0\n</code></pre>"},{"location":"reference/q3as.quadratic/VarType/","title":"VarType","text":"<p>               Bases: <code>Enum</code></p> <p>Constants defining variable type.</p> Source code in <code>q3as/quadratic/problems/types.py</code> <pre><code>class VarType(Enum):\n    \"\"\"Constants defining variable type.\"\"\"\n\n    CONTINUOUS = 0\n    BINARY = 1\n    INTEGER = 2\n</code></pre>"},{"location":"reference/q3as.quadratic/Variable/","title":"Variable","text":"<p>               Bases: <code>QuadraticProgramElement</code></p> <p>Representation of a variable.</p> Source code in <code>q3as/quadratic/problems/variable.py</code> <pre><code>class Variable(QuadraticProgramElement):\n    \"\"\"Representation of a variable.\"\"\"\n\n    Type = VarType\n\n    def __init__(\n        self,\n        quadratic_program: Any,\n        name: str,\n        lowerbound: Union[float, int] = 0,\n        upperbound: Union[float, int] = INFINITY,\n        vartype: VarType = VarType.CONTINUOUS,\n    ) -&gt; None:\n        \"\"\"Creates a new Variable.\n\n        The variables is exposed by the top-level `QuadraticProgram` class\n        in `QuadraticProgram.variables`.  This constructor is not meant to be used\n        externally.\n\n        Args:\n            quadratic_program: The parent QuadraticProgram.\n            name: The variable name.\n            lowerbound: The variable lowerbound.\n            upperbound: The variable upperbound.\n            vartype: The variable type.\n\n        Raises:\n            QiskitOptimizationError: if lowerbound is greater than upperbound.\n        \"\"\"\n        if lowerbound &gt; upperbound:\n            raise QiskitOptimizationError(\"Lowerbound is greater than upperbound!\")\n\n        super().__init__(quadratic_program)\n        self._name = name\n        self._lowerbound = lowerbound\n        self._upperbound = upperbound\n        self._vartype = vartype\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Returns the name of the variable.\n\n        Returns:\n            The name of the variable.\n        \"\"\"\n        return self._name\n\n    @property\n    def lowerbound(self) -&gt; Union[float, int]:\n        \"\"\"Returns the lowerbound of the variable.\n\n        Returns:\n            The lower bound of the variable.\n        \"\"\"\n        return self._lowerbound\n\n    @lowerbound.setter\n    def lowerbound(self, lowerbound: Union[float, int]) -&gt; None:\n        \"\"\"Sets the lowerbound of the variable.\n\n        Args:\n            lowerbound: The lower bound of the variable.\n\n        Raises:\n            QiskitOptimizationError: if lowerbound is greater than upperbound.\n        \"\"\"\n        if lowerbound &gt; self.upperbound:\n            raise QiskitOptimizationError(\"Lowerbound is greater than upperbound!\")\n        self._lowerbound = lowerbound\n\n    @property\n    def upperbound(self) -&gt; Union[float, int]:\n        \"\"\"Returns the upperbound of the variable.\n\n        Returns:\n            The upperbound of the variable.\n        \"\"\"\n        return self._upperbound\n\n    @upperbound.setter\n    def upperbound(self, upperbound: Union[float, int]) -&gt; None:\n        \"\"\"Sets the upperbound of the variable.\n\n        Args:\n            upperbound: The upperbound of the variable.\n\n        Raises:\n            QiskitOptimizationError: if upperbound is smaller than lowerbound.\n        \"\"\"\n        if self.lowerbound &gt; upperbound:\n            raise QiskitOptimizationError(\"Lowerbound is greater than upperbound!\")\n        self._upperbound = upperbound\n\n    @property\n    def vartype(self) -&gt; VarType:\n        \"\"\"Returns the type of the variable.\n\n        Returns:\n            The variable type.\n\n        \"\"\"\n        return self._vartype\n\n    @vartype.setter\n    def vartype(self, vartype: VarType) -&gt; None:\n        \"\"\"Sets the type of the variable.\n\n        Args:\n            vartype: The variable type.\n        \"\"\"\n        self._vartype = vartype\n\n    def as_tuple(self) -&gt; Tuple[str, Union[float, int], Union[float, int], VarType]:\n        \"\"\"Returns a tuple corresponding to this variable.\n\n        Returns:\n            A tuple corresponding to this variable consisting of name, lowerbound, upperbound and\n            variable type.\n        \"\"\"\n        return self.name, self.lowerbound, self.upperbound, self.vartype\n\n    def __repr__(self):\n        return f\"&lt;{self.__class__.__name__}: {str(self)}&gt;\"\n\n    def __str__(self):\n        if self._vartype == VarType.BINARY:\n            return f\"{self.name} ({self._vartype.name.lower()})\"\n        lowerbound = \"\" if self._lowerbound == -INFINITY else f\"{self._lowerbound} &lt;= \"\n        upperbound = \"\" if self._upperbound == INFINITY else f\" &lt;= {self._upperbound}\"\n        return f\"{lowerbound}{self.name}{upperbound} ({self._vartype.name.lower()})\"\n</code></pre>"},{"location":"reference/q3as.quadratic/Variable/#q3as.quadratic.Variable.lowerbound","title":"<code>lowerbound: Union[float, int]</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the lowerbound of the variable.</p> <p>Returns:</p> Type Description <code>Union[float, int]</code> <p>The lower bound of the variable.</p>"},{"location":"reference/q3as.quadratic/Variable/#q3as.quadratic.Variable.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns the name of the variable.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the variable.</p>"},{"location":"reference/q3as.quadratic/Variable/#q3as.quadratic.Variable.upperbound","title":"<code>upperbound: Union[float, int]</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the upperbound of the variable.</p> <p>Returns:</p> Type Description <code>Union[float, int]</code> <p>The upperbound of the variable.</p>"},{"location":"reference/q3as.quadratic/Variable/#q3as.quadratic.Variable.vartype","title":"<code>vartype: VarType</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the type of the variable.</p> <p>Returns:</p> Type Description <code>VarType</code> <p>The variable type.</p>"},{"location":"reference/q3as.quadratic/Variable/#q3as.quadratic.Variable.__init__","title":"<code>__init__(quadratic_program, name, lowerbound=0, upperbound=INFINITY, vartype=VarType.CONTINUOUS)</code>","text":"<p>Creates a new Variable.</p> <p>The variables is exposed by the top-level <code>QuadraticProgram</code> class in <code>QuadraticProgram.variables</code>.  This constructor is not meant to be used externally.</p> <p>Parameters:</p> Name Type Description Default <code>quadratic_program</code> <code>Any</code> <p>The parent QuadraticProgram.</p> required <code>name</code> <code>str</code> <p>The variable name.</p> required <code>lowerbound</code> <code>Union[float, int]</code> <p>The variable lowerbound.</p> <code>0</code> <code>upperbound</code> <code>Union[float, int]</code> <p>The variable upperbound.</p> <code>INFINITY</code> <code>vartype</code> <code>VarType</code> <p>The variable type.</p> <code>CONTINUOUS</code> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if lowerbound is greater than upperbound.</p> Source code in <code>q3as/quadratic/problems/variable.py</code> <pre><code>def __init__(\n    self,\n    quadratic_program: Any,\n    name: str,\n    lowerbound: Union[float, int] = 0,\n    upperbound: Union[float, int] = INFINITY,\n    vartype: VarType = VarType.CONTINUOUS,\n) -&gt; None:\n    \"\"\"Creates a new Variable.\n\n    The variables is exposed by the top-level `QuadraticProgram` class\n    in `QuadraticProgram.variables`.  This constructor is not meant to be used\n    externally.\n\n    Args:\n        quadratic_program: The parent QuadraticProgram.\n        name: The variable name.\n        lowerbound: The variable lowerbound.\n        upperbound: The variable upperbound.\n        vartype: The variable type.\n\n    Raises:\n        QiskitOptimizationError: if lowerbound is greater than upperbound.\n    \"\"\"\n    if lowerbound &gt; upperbound:\n        raise QiskitOptimizationError(\"Lowerbound is greater than upperbound!\")\n\n    super().__init__(quadratic_program)\n    self._name = name\n    self._lowerbound = lowerbound\n    self._upperbound = upperbound\n    self._vartype = vartype\n</code></pre>"},{"location":"reference/q3as.quadratic/Variable/#q3as.quadratic.Variable.as_tuple","title":"<code>as_tuple()</code>","text":"<p>Returns a tuple corresponding to this variable.</p> <p>Returns:</p> Type Description <code>str</code> <p>A tuple corresponding to this variable consisting of name, lowerbound, upperbound and</p> <code>Union[float, int]</code> <p>variable type.</p> Source code in <code>q3as/quadratic/problems/variable.py</code> <pre><code>def as_tuple(self) -&gt; Tuple[str, Union[float, int], Union[float, int], VarType]:\n    \"\"\"Returns a tuple corresponding to this variable.\n\n    Returns:\n        A tuple corresponding to this variable consisting of name, lowerbound, upperbound and\n        variable type.\n    \"\"\"\n    return self.name, self.lowerbound, self.upperbound, self.vartype\n</code></pre>"},{"location":"reference/q3as.quadratic/from_ising/","title":"from_ising","text":"<p>Create a quadratic program from a qubit operator and a shift value.</p> <p>Variables are mapped to qubits in the same order, i.e., i-th variable is mapped to i-th qubit. See https://github.com/Qiskit/qiskit-terra/issues/1148 for details.</p> <p>Parameters:</p> Name Type Description Default <code>qubit_op</code> <code>BaseOperator</code> <p>The qubit operator of the problem.</p> required <code>offset</code> <code>float</code> <p>The constant term in the Ising Hamiltonian.</p> <code>0.0</code> <code>linear</code> <code>bool</code> <p>If linear is True, :math:<code>x^2</code> is treated as a linear term since :math:<code>x^2 = x</code> for :math:<code>x \\in \\{0,1\\}</code>. Otherwise, :math:<code>x^2</code> is treat as a quadratic term. The default value is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>QuadraticProgram</code> <p>The quadratic program corresponding to the qubit operator.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>if there are Pauli Xs or Ys in any Pauli term</p> <code>QiskitOptimizationError</code> <p>if there are more than 2 Pauli Zs in any Pauli term</p> <code>QiskitOptimizationError</code> <p>if any Pauli term has an imaginary coefficient</p> Source code in <code>q3as/quadratic/translators/ising.py</code> <pre><code>def from_ising(\n    qubit_op: BaseOperator,\n    offset: float = 0.0,\n    linear: bool = False,\n) -&gt; QuadraticProgram:\n    r\"\"\"Create a quadratic program from a qubit operator and a shift value.\n\n    Variables are mapped to qubits in the same order, i.e.,\n    i-th variable is mapped to i-th qubit.\n    See https://github.com/Qiskit/qiskit-terra/issues/1148 for details.\n\n    Args:\n        qubit_op: The qubit operator of the problem.\n        offset: The constant term in the Ising Hamiltonian.\n        linear: If linear is True, :math:`x^2` is treated as a linear term\n            since :math:`x^2 = x` for :math:`x \\in \\{0,1\\}`.\n            Otherwise, :math:`x^2` is treat as a quadratic term.\n            The default value is False.\n\n    Returns:\n        The quadratic program corresponding to the qubit operator.\n\n    Raises:\n        QiskitOptimizationError: if there are Pauli Xs or Ys in any Pauli term\n        QiskitOptimizationError: if there are more than 2 Pauli Zs in any Pauli term\n        QiskitOptimizationError: if any Pauli term has an imaginary coefficient\n    \"\"\"\n    # quantum_info\n    if isinstance(qubit_op, BaseOperator):\n        if not isinstance(qubit_op, SparsePauliOp):\n            qubit_op = SparsePauliOp.from_operator(Operator(qubit_op))\n\n    quad_prog = QuadraticProgram()\n    quad_prog.binary_var_list(qubit_op.num_qubits)\n\n    # prepare a matrix of coefficients of Pauli terms\n    # `pauli_coeffs_diag` is the diagonal part\n    # `pauli_coeffs_triu` is the upper triangular part\n    pauli_coeffs_diag = [0.0] * qubit_op.num_qubits\n    pauli_coeffs_triu = {}\n\n    for pauli_op in qubit_op:\n        pauli = pauli_op.paulis[0]\n        coeff = pauli_op.coeffs[0]\n\n        if not math.isclose(coeff.imag, 0.0, abs_tol=1e-10):\n            raise QiskitOptimizationError(f\"Imaginary coefficient exists: {pauli_op}\")\n\n        if np.any(pauli.x):\n            raise QiskitOptimizationError(\n                f\"Pauli X or Y exists in the Pauli term: {pauli}\"\n            )\n\n        # indices of Pauli Zs in the Pauli term\n        z_index = np.where(pauli.z)[0]\n        num_z = len(z_index)\n\n        if num_z == 0:\n            offset += coeff.real\n        elif num_z == 1:\n            pauli_coeffs_diag[z_index[0]] = coeff.real\n        elif num_z == 2:\n            pauli_coeffs_triu[z_index[0], z_index[1]] = coeff.real\n        else:\n            raise QiskitOptimizationError(\n                f\"There are more than 2 Pauli Zs in the Pauli term: {pauli}\"\n            )\n\n    linear_terms = {}\n    quadratic_terms = {}\n\n    # For quadratic pauli terms of operator\n    # x_i * x_j = (1 - Z_i - Z_j + Z_i * Z_j)/4\n    for (i, j), weight in pauli_coeffs_triu.items():\n        # Add a quadratic term to the objective function of `QuadraticProgram`\n        # The coefficient of the quadratic term in `QuadraticProgram` is\n        # 4 * weight of the pauli\n        quadratic_terms[i, j] = 4 * weight\n        pauli_coeffs_diag[i] += weight\n        pauli_coeffs_diag[j] += weight\n        offset -= weight\n\n    # After processing quadratic pauli terms, only linear paulis are left\n    # x_i = (1 - Z_i)/2\n    for i, weight in enumerate(pauli_coeffs_diag):\n        # Add a linear term to the objective function of `QuadraticProgram`\n        # The coefficient of the linear term in `QuadraticProgram` is\n        # 2 * weight of the pauli\n        if linear:\n            linear_terms[i] = -2 * weight\n        else:\n            quadratic_terms[i, i] = -2 * weight\n        offset += weight\n\n    quad_prog.minimize(constant=offset, linear=linear_terms, quadratic=quadratic_terms)\n\n    return quad_prog\n</code></pre>"},{"location":"reference/q3as.quadratic/to_ising/","title":"to_ising","text":"<p>Return the Ising Hamiltonian of this problem.</p> <p>Variables are mapped to qubits in the same order, i.e., i-th variable is mapped to i-th qubit. See https://github.com/Qiskit/qiskit-terra/issues/1148 for details.</p> <p>Parameters:</p> Name Type Description Default <code>quad_prog</code> <code>QuadraticProgram</code> <p>The problem to be translated.</p> required <p>Returns:</p> Type Description <code>SparsePauliOp</code> <p>A tuple (qubit_op, offset) comprising the qubit operator for the problem</p> <code>float</code> <p>and offset for the constant value in the Ising Hamiltonian.</p> <p>Raises:</p> Type Description <code>QiskitOptimizationError</code> <p>If an integer variable or a continuous variable exists in the problem.</p> <code>QiskitOptimizationError</code> <p>If constraints exist in the problem.</p> Source code in <code>q3as/quadratic/translators/ising.py</code> <pre><code>def to_ising(quad_prog: QuadraticProgram) -&gt; Tuple[SparsePauliOp, float]:\n    \"\"\"Return the Ising Hamiltonian of this problem.\n\n    Variables are mapped to qubits in the same order, i.e.,\n    i-th variable is mapped to i-th qubit.\n    See https://github.com/Qiskit/qiskit-terra/issues/1148 for details.\n\n    Args:\n        quad_prog: The problem to be translated.\n\n    Returns:\n        A tuple (qubit_op, offset) comprising the qubit operator for the problem\n        and offset for the constant value in the Ising Hamiltonian.\n\n    Raises:\n        QiskitOptimizationError: If an integer variable or a continuous variable exists\n            in the problem.\n        QiskitOptimizationError: If constraints exist in the problem.\n    \"\"\"\n    # if problem has variables that are not binary, raise an error\n    if quad_prog.get_num_vars() &gt; quad_prog.get_num_binary_vars():\n        raise QiskitOptimizationError(\n            \"The type of all variables must be binary. \"\n            \"You can use `QuadraticProgramToQubo` converter \"\n            \"to convert integer variables to binary variables. \"\n            \"If the problem contains continuous variables, `to_ising` cannot handle it. \"\n            \"You might be able to solve it with `ADMMOptimizer`.\"\n        )\n\n    # if constraints exist, raise an error\n    if quad_prog.linear_constraints or quad_prog.quadratic_constraints:\n        raise QiskitOptimizationError(\n            \"There must be no constraint in the problem. \"\n            \"You can use `QuadraticProgramToQubo` converter \"\n            \"to convert constraints to penalty terms of the objective function.\"\n        )\n\n    # initialize Hamiltonian.\n    num_vars = quad_prog.get_num_vars()\n    pauli_list = []\n    offset = 0.0\n    zero = np.zeros(num_vars, dtype=bool)\n\n    # set a sign corresponding to a maximized or minimized problem.\n    # sign == 1 is for minimized problem. sign == -1 is for maximized problem.\n    sense = quad_prog.objective.sense.value\n\n    # convert a constant part of the objective function into Hamiltonian.\n    offset += quad_prog.objective.constant * sense\n\n    # convert linear parts of the objective function into Hamiltonian.\n    for idx, coef in quad_prog.objective.linear.to_dict().items():\n        z_p = zero.copy()\n        weight = coef * sense / 2\n        z_p[idx] = True\n\n        pauli_list.append(SparsePauliOp(Pauli((z_p, zero)), -weight))\n        offset += weight\n\n    # create Pauli terms\n    for (i, j), coeff in quad_prog.objective.quadratic.to_dict().items():\n        weight = coeff * sense / 4\n\n        if i == j:\n            offset += weight\n        else:\n            z_p = zero.copy()\n            z_p[i] = True\n            z_p[j] = True\n            pauli_list.append(SparsePauliOp(Pauli((z_p, zero)), weight))\n\n        z_p = zero.copy()\n        z_p[i] = True\n        pauli_list.append(SparsePauliOp(Pauli((z_p, zero)), -weight))\n\n        z_p = zero.copy()\n        z_p[j] = True\n        pauli_list.append(SparsePauliOp(Pauli((z_p, zero)), -weight))\n\n        offset += weight\n\n    if pauli_list:\n        # Remove paulis whose coefficients are zeros.\n        qubit_op = sum(pauli_list).simplify(atol=0)\n    else:\n        # If there is no variable, we set num_nodes=1 so that qubit_op should be an operator.\n        # If num_nodes=0, I^0 = 1 (int).\n        num_vars = max(1, num_vars)\n        qubit_op = SparsePauliOp(\"I\" * num_vars, 0)\n\n    return qubit_op, offset\n</code></pre>"}]}